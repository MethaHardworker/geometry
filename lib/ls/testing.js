// Generated by LiveScript 1.6.0
(function(){
  var M, C, S, failedParams, failedFigures, failedTests, runTests, foldJSON, runTest, runProperty, reportSuccess, reportFail, checkProperty, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  M = Monoid;
  C = console;
  S = Sequence;
  failedParams = {};
  failedFigures = {};
  failedTests = {};
  runTests = function(json){
    var go, normalization, normalized;
    go = function(t){
      var i$, ref$, len$, entry;
      switch (false) {
      case !t.run:
        return runTest(t);
      case !t['for']:
        return runProperty(t);
      case !t.suite:
        if (t.log && t.name) {
          C.group("Testing " + t.name);
        }
        for (i$ = 0, len$ = (ref$ = t.suite).length; i$ < len$; ++i$) {
          entry = ref$[i$];
          go(entry);
        }
        if (t.log && t.name) {
          return C.groupEnd();
        }
        break;
      case !t.skip:
        break;
      default:

      }
    };
    normalization = [foldJSON('name', M.path(':'), ''), foldJSON('log', M.or), foldJSON('number', M.keep, json.number) || 100];
    normalized = M.fold(M.composition, normalization);
    return go(normalized(json));
  };
  foldJSON = function(field, m, mempty){
    var empty, go;
    empty = m.mempty || mempty;
    go = function(value){
      return function(json){
        var res, newvalue, rec;
        res = import$({}, json);
        newvalue = m.mappend(value, res[field] || empty);
        rec = {};
        if (res.suite) {
          rec.suite = map(go(newvalue), res.suite);
        } else {
          res[field] = newvalue;
        }
        return import$(res, rec);
      };
    };
    return function(json){
      return go(json[field] || empty)(json);
    };
  };
  runTest = function(test){
    var result;
    if (!test.skip) {
      if (test.log) {
        C.log("Testing " + test.name + "...");
      }
      result = test.run();
      if (!equal(result, test.result)) {
        C.groupCollapsed('%cTest %s failed', 'color:red', test.name);
        C.log('  expected: %c%s', 'color:blue', test.result.toString());
        C.log('  got:      %c%s', 'color:blue', result.toString());
        return C.groupEnd();
      } else {
        if (test.log) {
          return C.log("%cPassed.", 'color:darkgreen');
        }
      }
    }
  };
  runProperty = function(data){
    var options, res;
    options = {
      skip: false,
      assuming: [],
      hold: function(){
        return true;
      },
      shrinks: 500,
      including: [],
      number: 123
    };
    import$(options, data);
    if (!options.skip) {
      if (options.log) {
        C.log("Testing " + options.name + " ...");
      }
      res = checkProperty(options);
      switch (false) {
      case !(res.applied === 0):
        return C.log("%cNone of samples in test \"%s\" passed assumptions!", 'color:red', options['name']);
      case !res.ok:
        return reportSuccess(res, options);
      default:
        return reportFail(res, options);
      }
    }
  };
  reportSuccess = function(res, options){
    var passed, color;
    if (options.log) {
      passed = res.applied / res.samples;
      color = (function(){
        switch (false) {
        case !(passed < 0.25):
          return 'orange';
        case !(passed < 0.5):
          return 'goldenrod';
        default:
          return 'darkgreen';
        }
      }());
      return C.log('%cOk. Total samples: %d, %cpassed assumptions: %s', 'color:darkgreen', res.samples, 'color:' + color, fmt.percent(passed));
    }
  };
  reportFail = function(res, options){
    var augmentedArgs, name, params, i$, len$, x;
    augmentedArgs = options['with'] || function(){
      var x, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      x = res$;
      return arrayFrom$(x);
    };
    name = options.name;
    params = apply(augmentedArgs, res.sample);
    C.groupCollapsed("%cProperty " + name + " failed!", 'color: red');
    C.log("Counter example (" + res.shrinks + " shrinks):");
    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
      x = params[i$];
      C.log('%c' + x.toString(), 'color: blue');
    }
    C.groupEnd();
    failedParams[name] = params;
    failedTests[name] = options;
    return failedFigures[name] = new Group(params.filter(x(function(){
      return x instanceof Figure;
    })));
  };
  checkProperty = function(options){
    var ac, c, sc, augmentedArgs, assertion, assumption, proposition, test, obligatory, samples, shrinker, simplicity, number, run, runc, res, counts;
    ac = {
      counter: 0
    };
    c = {
      counter: 0
    };
    sc = {
      counter: -2
    };
    augmentedArgs = options['with'] || function(){
      var x, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      x = res$;
      return arrayFrom$(x);
    };
    assertion = compose(options.hold, augmentedArgs);
    assumption = count(c)(function(x){
      return apply(conjunction(options.assuming), x);
    });
    proposition = count(ac)(function(x){
      return apply(assertion, x);
    });
    test = implies(assumption, proposition);
    obligatory = S.listProduct(options.including);
    samples = function(){
      return new Arbitrary().tuple(options['for']).ascending();
    };
    shrinker = samples().shrink;
    simplicity = function(r){
      if (r.sample) {
        return samples().simplicity(r.sample);
      } else {
        return Infinity;
      }
    };
    number = options.number;
    run = function(seq, ok, depth, last){
      var res, h, sh;
      ok == null && (ok = true);
      depth == null && (depth = 0);
      res = seq.dropWhile(test);
      switch (false) {
      case !res.isEmpty:
        return {
          ok: ok,
          sample: last
        };
      case !(!ok && res.tail.isEmpty):
        return {
          ok: ok,
          sample: res.head
        };
      default:
        h = res.head;
        sh = shrinker(h).take(options.shrinks);
        switch (false) {
        case !(depth > options.shrinks):
          return {
            ok: ok,
            sample: h
          };
        case !sh.isEmpty:
          return {
            ok: ok,
            sample: h
          };
        default:
          return runc(sh, false, depth + 1, h);
        }
      }
    };
    runc = count(sc)(run);
    res = runc(samples().take(number));
    counts = {
      samples: c.counter,
      applied: ac.counter,
      shrinks: sc.counter
    };
    return import$(res, counts);
  };
  window.runTests = runTests;
  window.ap = ap;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
