// Generated by LiveScript 1.6.0
(function(){
  var Gen, Sequence, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  Gen = (function(){
    Gen.displayName = 'Gen';
    var insert, prototype = Gen.prototype, constructor = Gen;
    Gen.destr = function(g){
      var x;
      x = g.next();
      if (x.done) {
        return null;
      } else {
        return {
          head: x.value,
          tail: g
        };
      }
    };
    Gen.rnd = function*(a, b, f){
      f == null && (f = id);
      for (;;) {
        (yield f(a + (b - a) * Math.random()));
      }
    };
    Gen.iterate = function*(f, x0){
      var x;
      (yield (x = x0));
      for (;;) {
        (yield (x = f(x)));
      }
    };
    Gen.bind = function*(g, proc){
      var x;
      while (!(x = g.next()).done) {
        (yield* proc(x.value));
      }
    };
    Gen.product = function*(gs){
      (yield* (yield* (function*(){
        switch (false) {
        case gs.length !== 0:
          return function*(){};
        case gs.length !== 1:
          return constructor.bind(gs[0](), function*(x){
            (yield [x]);
          });
        case !(gs.length >= 0):
          return constructor.bind(gs[0](), function*(x){
            (yield* constructor.bind(constructor.product(
            tail(gs)), function*(xs){
              (yield [x].concat(xs));
            }));
          });
        }
      }())));
    };
    Gen.sum = function*(gs){
      switch (false) {
      case gs.length !== 0:
        return;
      case !(gs.length >= 0):
        (yield* gs[0]);
        (yield* constructor.sum(
        tail(gs)));
      }
    };
    Gen.zip = function*(gs){
      var res;
      for (;;) {
        res = map(fn$, gs);
        if (any(fn1$, res)) {
          break;
        }
        (yield map(fn2$, res));
      }
      function fn$(it){
        return it.next();
      }
      function fn1$(it){
        return it.done;
      }
      function fn2$(it){
        return it.value;
      }
    };
    Gen.apply = curry$(function*(f, g){
      var x;
      while (!(x = g.next()).done) {
        (yield apply(f, x.value));
      }
    });
    Gen.map = curry$(function*(f, g){
      var x;
      while (!(x = g.next()).done) {
        (yield f(x.value));
      }
    });
    Gen.take = curry$(function*(n, g){
      var i, x;
      i = n;
      while (!(i-- <= 0 || (x = g.next()).done)) {
        (yield x.value);
      }
    });
    Gen.list = function*(lst){
      var i$, len$, x;
      for (i$ = 0, len$ = lst.length; i$ < len$; ++i$) {
        x = lst[i$];
        (yield x);
      }
    };
    Gen.cons = function*(x, g){
      (yield x);
      (yield* g);
    };
    Gen.dropWhile = curry$(function*(p, g){
      var x;
      while (!((x = g.next()).done || !p(x.value))) {}
      if (!x.done) {
        (yield x.value);
        (yield* g);
      }
    });
    Gen.takeWhile = curry$(function*(p, g){
      var x;
      while (!(x = g.next()).done && p(x.value)) {
        if (p(x.value)) {
          (yield x.value);
        }
      }
    });
    Gen.filter = curry$(function*(p, g){
      var x;
      while (!(x = g.next()).done) {
        if (p(x)) {
          (yield x);
        }
      }
    });
    Gen.tail = function*(g){
      g.next();
      (yield* g);
    };
    insert = function(lst, x, f){
      f == null && (f = id);
      switch (false) {
      case lst.length !== 0:
        return [x];
      case !(f(lst[0]) >= f(x)):
        return [x].concat(lst);
      default:
        return [lst[0]].concat(insert(tail(lst), x, f));
      }
    };
    Gen.ascendingBy = function(f, x0){
      return function*(g){
        var buffer, i$, x;
        buffer = [x0];
        for (i$ = 0; i$ <= 32; ++i$) {
          x = g.next();
          if (x.done) {
            break;
          }
          buffer = insert(buffer, x.value, f);
        }
        (yield* Gen.list(buffer));
        while (!(x = g.next()).done) {
          buffer = insert(buffer, x, f);
          (yield buffer.shift());
        }
      };
    };
    function Gen(){}
    return Gen;
  }());
  Sequence = (function(){
    Sequence.displayName = 'Sequence';
    var prototype = Sequence.prototype, constructor = Sequence;
    function Sequence(gen){
      var g, step;
      gen == null && (gen = []);
      g = Array.isArray(gen) ? Gen.list(gen) : gen;
      step = g.next();
      this.head = step.value;
      this.isEmpty = step.done;
      this.tailGen = function(){
        return g;
      };
    }
    Sequence.iterate = function(f, x){
      return new Sequence(Gen.iterate(f, x));
    };
    Sequence.prototype.generator = function(){
      return Gen.cons(this.head, this.tailGen());
    };
    Object.defineProperty(Sequence.prototype, 'list', {
      get: function(){
        var res;
        switch (false) {
        case !this.isEmpty:
          return [];
        default:
          res = arrayFrom$(this.generator());
          this.isEmpty = true;
          this.head = undefined;
          return res;
        }
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(Sequence.prototype, 'tail', {
      get: function(){
        return this.setGen(this.tailGen());
      },
      configurable: true,
      enumerable: true
    });
    Sequence.prototype.setGen = function(g){
      var step, x$;
      step = g.next();
      x$ = this;
      x$.head = step.value;
      x$.isEmpty = step.done;
      x$.tailGen = function(){
        return g;
      };
      return x$;
    };
    Sequence.prototype.modGen = function(f){
      return this.setGen(f(this.generator()));
    };
    Sequence.prototype.next = function(){
      var step, x$;
      step = this.tailGen().next();
      x$ = this;
      x$.head = step.value;
      x$.isEmpty = step.done;
      return x$;
    };
    Sequence.prototype.take = function(n){
      return this.setGen(Gen.take(n)(Gen.cons(this.head, this.tailGen())));
    };
    Sequence.tuple = function(seqs){
      var empty, x$;
      empty = any(function(it){
        return it.isEmpty;
      }, seqs);
      x$ = new Sequence();
      x$.isEmpty = empty;
      x$.head = empty
        ? undefined
        : map(function(it){
          return it.head;
        }, seqs);
      x$.tailGen = function(){
        return Gen.zip(map(function(it){
          return it.tailGen();
        }, seqs));
      };
      x$.elements = seqs;
      return x$;
    };
    Sequence.sum = function(seqs){
      var s, x$;
      switch (false) {
      case seqs.length !== 0:
        return new Sequence([]);
      case !otherwize:
        s = map(function(it){
          return it.generator();
        }(seqs));
        x$ = new Sequence(Gen.sum(s));
        x$.elements = seqs[0].elements;
        return x$;
      }
    };
    Sequence.listProduct = function(ls){
      switch (false) {
      case ls.length !== 0:
        return new Sequence([]);
      case !(ls.length > 0):
        return new Sequence(Gen.product(map(function(l){
          return function(){
            return Gen.list(l);
          };
        }, ls)));
      }
    };
    Sequence.prototype.apply = function(f){
      return this.modGen(Gen.apply(f));
    };
    Sequence.prototype.map = function(f){
      return this.modGen(Gen.map(f));
    };
    Sequence.prototype.dropWhile = function(f){
      return this.modGen(Gen.dropWhile(f));
    };
    Sequence.prototype.takeWhile = function(f){
      return this.modGen(Gen.takeWhile(f));
    };
    Sequence.prototype.filter = function(p){
      return this.modGen(Gen.filter(p));
    };
    Sequence.prototype.ascendingBy = function(f, x0){
      return this.modGen(Gen.ascendingBy(f, x0));
    };
    Sequence.prototype.toString = function(){
      if (this.isEmpty) {
        return "<empty>";
      } else {
        return "<" + this.head.toString() + " ...>";
      }
    };
    return Sequence;
  }());
  window.Gen = Gen;
  window.Sequence = Sequence;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
