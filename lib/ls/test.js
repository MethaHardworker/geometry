// Generated by LiveScript 1.6.0
(function(){
  var implies, labeled, anyParam, anyXY, anyPoint, anyAngleValue, mkAngle, anyAngle, anyLine, anySegment, anyRay, anyRadius, anyCircle, anyTriangle, any, testTests, testPoints, testTransformations, testLines, testRays, testSegments, testGroup, testIntersections, testAngles, testCircle, testPolygon, testSquare, allTests;
  implies = function(P, Q){
    if (P) {
      return Q;
    } else {
      return true;
    }
  };
  labeled = function(l){
    return function(f){
      return function(){
        var x, res$, i$, to$;
        res$ = [];
        for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
          res$.push(arguments[i$]);
        }
        x = res$;
        if (l) {
          return f.apply(null, x).label(l);
        } else {
          return f.apply(null, x);
        }
      };
    };
  };
  anyParam = function(a, b){
    a == null && (a = 0);
    b == null && (b = 1);
    return anyNum().range(a, b).precision(0.01).ascending();
  };
  anyXY = function(){
    return ArbitraryCoordinates();
  };
  anyPoint = function(l){
    return args(anyXY()).iso(labeled(l)(point), function(p){
      return [p.xy];
    });
  };
  anyAngleValue = function(){
    return new ArbitraryNumber(0, 360).precision(1).ascending();
  };
  mkAngle = function(v, s, e){
    var x$;
    x$ = new Angle();
    x$.vertex = v;
    x$.start = s;
    x$.end = e;
    return x$;
  };
  anyAngle = function(){
    return args(anyPoint(), anyAngleValue(), anyAngleValue()).iso(mkAngle, function(a){
      return [a.vertex, a.start, a.end];
    });
  };
  anyLine = function(l){
    return args(anyPoint(), anyPoint()).iso(labeled(l)(line), function(l){
      return [l.point(0), l.point(1)];
    });
  };
  anySegment = function(l){
    return args(anyPoint(), anyPoint()).iso(labeled(l)(segment), function(l){
      return [l.point(0), l.point(1)];
    });
  };
  anyRay = function(l){
    return args(anyPoint(), anyAngleValue()).iso(labeled(l)(ray), function(r){
      return [r.start, r.angle(0)];
    });
  };
  anyRadius = function(){
    return anyNum().range(1, paperSize / 4).precision(1).ascending();
  };
  anyCircle = function(){
    return args(anyPoint(), anyRadius()).iso(circle, function(c){
      return [c.center, c.R];
    }).ascending();
  };
  anyTriangle = function(){
    return args(anyPoint(), anyPoint(), anyPoint()).iso(new Triangle, function(c){
      return c.vertices;
    }).filter(function(t){
      return t.isNontrivial;
    });
  };
  any = {
    num: anyNum,
    param: anyParam,
    point: anyPoint,
    XY: anyXY,
    angle: anyAngle,
    angleValue: anyAngleValue,
    line: anyLine,
    ray: anyRay,
    segment: anySegment,
    circle: anyCircle,
    triangle: anyTriangle
  };
  window.any = any;
  testTests = {
    name: 'Tests',
    skip: true,
    log: true,
    suite: [
      {
        name: "1",
        'for': [anyNum().range(0, 100).precision(0.1)],
        hold: function(n){
          return n === 4;
        },
        number: 10
      }, {
        name: "2",
        'for': [anyNum(), anyNum()],
        hold: function(n, m){
          return n >= m;
        },
        log: false
      }, {
        name: "3",
        'for': [anyCircle(), anyPoint()],
        assuming: function(c, p){
          return c.R > 1 && c.center.isNotEqual(p);
        },
        hold: function(c, p){
          return !c.isEnclosing(p);
        }
      }
    ]
  };
  testPoints = {
    name: 'Points',
    number: 10,
    suite: [
      {
        name: "isomorphism 1",
        'for': [anyPoint('A')],
        holds: function(p){
          return Point.iso(Point.iso(p).xy).point.isEqual(p);
        }
      }, {
        name: "copy 1",
        run: function(){
          return point([3, 4]).copy();
        },
        result: point([3, 4])
      }, {
        name: "superpose",
        'for': [anyPoint(), anyPoint()],
        holds: function(p1, p2){
          return p1.superpose(p1, p2).isEqual(p2);
        }
      }, {
        name: "isomorphism 1",
        'for': [anyPoint()],
        hold: function(p){
          return Point.iso(Point.iso(p).xy).point.isEqual(p);
        }
      }, {
        name: "isomorphism 2",
        'for': [anyXY()],
        hold: function(xy){
          return equal(Point.iso(Point.iso(xy).point).xy, xy);
        }
      }, {
        name: "copy 1",
        'for': [anyPoint()],
        hold: function(p){
          return p.copy().isEqual(p);
        }
      }, {
        name: "coordinates 1",
        'for': [anyPoint()],
        hold: function(p){
          return origin.at(p).isEqual(point(p));
        }
      }, {
        name: "equality 1",
        'for': [anyPoint()],
        hold: function(p){
          return p.isEqual(p);
        }
      }, {
        name: "equality 2",
        'for': [anyPoint()],
        hold: function(p){
          return point(p.xy).isEqual(p);
        }
      }, {
        name: "equality 3",
        'for': [anyPoint()],
        hold: function(p){
          return !p.copy().translate([1, 1]).isEqual(p);
        }
      }, {
        name: "translate 1",
        run: function(){
          return new Point().translate([1, 2]).xy;
        },
        result: [1, 2]
      }
    ]
  };
  testTransformations = {
    name: 'Transformations',
    suite: []
  };
  testLines = {
    name: 'Lines',
    suite: [
      {
        number: 10,
        suite: [
          {
            name: "isomorphism 1",
            'for': [anyLine(), anyNum()],
            assuming: [function(l){
              return l.isNontrivial;
            }],
            hold: function(l, s){
              return equal(l.locus(l.point(s)), s);
            }
          }, {
            name: "isomorphism 2",
            'for': [anyPoint(), anyNum()],
            where: function(p, s){
              return [l, s];
            },
            hold: function(p, s){
              var l;
              l = line(p, p);
              return l.isTrivial && equal(l.locus(l.point(s)), 0);
            }
          }, {
            name: "isomorphism 3",
            'for': [anyLine(), anyNum()],
            assuming: [function(l){
              return l.isNontrivial;
            }],
            hold: function(l, s){
              var p;
              p = l.point(s);
              return equal(l.point(l.locus(p)), p);
            }
          }, {
            name: "equation 1",
            'for': [anyLine(), anyNum()],
            hold: function(l, s){
              return l.equation(l.point(s));
            }
          }, {
            name: "equation 2",
            'for': [anyLine(), anyNum()],
            assuming: [function(l){
              return l.isNontrivial;
            }],
            hold: function(l, s){
              return !l.equation(l.point(s).translate(l.normalV(0)));
            }
          }
        ]
      }, {
        name: "line intersections 1",
        'for': [anyLine(), anyLine()],
        assuming: [function(a, b){
          return !(a.isTrivial || b.isTrivial);
        }],
        hold: function(a, b){
          return a.intersections(b).length === (a.isParallelTo(b) ? 0 : 1);
        }
      }, {
        name: "plane intersections 1",
        'for': [anyLine()],
        assuming: [function(l){
          return plane.isEnclosing(l.refPoint);
        }],
        hold: function(l){
          var pts;
          pts = plane.intersections(l);
          return pts.every(function(p){
            return plane.isContaining(p);
          });
        }
      }, {
        name: "perpendicularity 1",
        'for': [anyLine('a'), anyPoint('A')],
        'with': function(l, p){
          return [l, p, new Line('b').at(p).perpendicularTo(l)];
        },
        assuming: [function(l){
          return l.isNontrivial;
        }],
        hold: function(l, p, nl){
          return nl.isPerpendicularTo(l);
        }
      }, {
        name: "perpendicularity 2",
        'for': [anyLine()],
        hold: function(l){
          return !l.isPerpendicularTo(line(origin, origin));
        }
      }, {
        name: "perpendicularity 3",
        'for': [anyLine('1'), anyLine('2')],
        'with': function(l1, l2){
          return [l1, l2, l1.perpendicularTo(l2).label('p')];
        },
        assuming: [function(l1, l2, p){
          return l1.isNontrivial && l2.isNontrivial;
        }],
        hold: function(l1, l2, p){
          return p.refPoint.isEqual(l1.refPoint) && gequal(p.locus(p.intersections(l2)[0]), 0);
        }
      }, {
        name: "parallelity 1",
        'for': [anyLine(), anyXY()],
        assuming: [function(l){
          return l.isNontrivial;
        }],
        hold: function(l, xy){
          return new Line().at(xy).parallelTo(l).isParallelTo(l);
        }
      }, {
        name: "parallelity 2",
        'for': [anyLine()],
        hold: function(l){
          return !l.isParallelTo(line(origin, origin));
        }
      }, {
        name: "tangentTo 1",
        'for': [anyPoint(), anyCircle()],
        'with': function(p, c){
          var t, i;
          t = new Line().at(p).tangentTo(c);
          i = c.intersections(t);
          return [p, c, t, i];
        },
        hold: function(p, c, t, i){
          return i.length === 1 && new Line().at(i[0]).perpendicularTo(t).isContaining(c.center);
        },
        assuming: [function(p, c){
          return c.isNontrivial && !c.isEnclosing(p);
        }]
      }, {
        name: "tangentTo 2",
        'for': [anyCircle(), anyParam()],
        'with': function(c, x){
          return [c, x, new Line().at(c.point(x)).tangentTo(c)];
        },
        hold: function(c, x, t){
          return t.isPerpendicularTo(c.radius(x));
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }, {
        name: 'tangentTo 3',
        'for': [anyPoint(), anyCircle()],
        'with': function(p, c){
          var t1, t2, i1, i2;
          t1 = new Line().at(p).tangentTo(c, 1);
          t2 = new Line().at(p).tangentTo(c, -1);
          i1 = c.locus(c.intersections(t1)[0]);
          i2 = c.locus(c.intersections(t2)[0]);
          return [p, c, t1, t2, i1, i2];
        },
        hold: function(p, c, t1, t2, i1, i2){
          return t1.vector.dot(c.tangentV(i1)) > 0 && t2.vector.dot(c.tangentV(i2)) < 0;
        },
        assuming: [function(p, c){
          return c.isNontrivial && !c.isEnclosing(p);
        }]
      }, {
        name: 'LineEquation',
        number: 10,
        suite: [
          {
            name: '1',
            'for': [anyXY(), anyXY()],
            hold: function(p1, p2){
              return lineEquation(p1, p2)(0).isEqual(point(p1));
            }
          }, {
            name: '2',
            'for': [anyXY(), anyXY()],
            hold: function(p1, p2){
              return lineEquation(p1, p2)(1).isEqual(point(p2));
            }
          }, {
            name: '4',
            run: function(){
              return lineEquation([0, 0], [1, 2], 2)(1);
            },
            result: point([2, 4])
          }, {
            name: '5',
            run: function(){
              return lineEquation([0, 0], [1, 2], 2)(-1);
            },
            result: point([-2, -4])
          }, {
            name: '6',
            run: function(){
              return lineEquation([0, 0], [0, 1])(0);
            },
            result: point([0, 0])
          }, {
            name: '7',
            run: function(){
              return lineEquation([0, 0], [0, 1])(2);
            },
            result: point([0, 2])
          }, {
            name: '8',
            run: function(){
              return lineEquation([1, 2], [1, 2])(0);
            },
            result: point([1, 2])
          }, {
            name: '9',
            run: function(){
              return lineEquation([1, 2], [1, 2])(1);
            },
            result: point([1, 2])
          }, {
            name: '10',
            run: function(){
              return lineEquation([1, 2], [0, 0], -1)(0);
            },
            result: point([1, 2])
          }, {
            name: '11',
            run: function(){
              return lineEquation([1, 2], [0, 0], -1)(1);
            },
            result: point([2, 4])
          }
        ]
      }, {
        name: "intersectionV",
        suit: [
          {
            name: '1',
            run: function(){
              return intersectionV([0, 0], [1, 2], [0, 0], [2, 1]);
            },
            result: [0, 0]
          }, {
            name: '2',
            run: function(){
              return intersectionV([1, 2], [1, 1], [2, 1], [-1, 1]);
            },
            result: [1, 2]
          }, {
            name: '3',
            run: function(){
              return intersectionV([1, 0], [0, 1], [0, 1], [1, 0]);
            },
            result: [1, 1]
          }, {
            name: '5',
            run: function(){
              return intersectionV([1, 2], [-1, -2], [3, 4], [-3, -4]);
            },
            result: [0, 0]
          }, {
            name: '6',
            run: function(){
              return intersectionV([1, 2], [1, 2], [3, 4], [2, 4]);
            },
            result: [Infinity, Infinity]
          }, {
            name: '7',
            run: function(){
              return intersectionV([1, 2], [1, 2], [1, 2], [-2, -4]);
            },
            result: [Infinity, Infinity]
          }
        ]
      }
    ]
  };
  testRays = {
    name: 'Rays',
    suite: [
      {
        name: "is-containing 1",
        'for': [anyRay(), anyNum()],
        assuming: [function(r){
          return r.isNontrivial;
        }],
        hold: function(r, s){
          return s >= 0 && r.isContaining(r.point(s));
        }
      }, {
        name: "is-containing 2",
        'for': [anyRay(), anyNum()],
        assuming: [function(r){
          return r.isNontrivial;
        }],
        hold: function(r, s){
          return !r.isContaining(r.point(s).translate(r.normalV(0)));
        }
      }, {
        name: "tangent-to",
        'for': [anyCircle(), anyParam()],
        'with': function(c, x){
          var p, t1, t2;
          p = c.point(x);
          t1 = new Ray().at(p).tangentTo(c, 1);
          t2 = new Ray().at(p).tangentTo(c, -1);
          return [c, x, t1, t2, p];
        },
        hold: function(c, x, t1, t2){
          return t1.vector.dot(c.tangentV(x)) > 0 && t2.vector.dot(c.tangentV(x)) < 0;
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }
    ]
  };
  testSegments = {
    name: 'Segments',
    suite: [
      {
        name: "is-containing 1",
        'for': [anySegment(), anyNum()],
        assuming: [function(s){
          return s.isNontrivial;
        }],
        hold: function(s, t){
          return implies(0 <= t && t <= 1, s.isContaining(s.point(t)));
        }
      }, {
        name: "extension 1",
        'for': [anySegment(), anyNum()],
        hold: function(s, n){
          return equal(s.extend(n).length, abs(n) * s.length);
        }
      }, {
        name: "extension 2",
        'for': [anySegment(), anyNum()],
        hold: function(s, n){
          return equal(s.extend(n).extend(n).length, n * n * s.length);
        }
      }, {
        name: "extension 3",
        'for': [anySegment(), anyNum()],
        assuming: [function(_, n){
          return n >= 0;
        }],
        hold: function(s, n){
          return equal(s.extendToLength(n).length, s.isTrivial ? 0 : n);
        }
      }, {
        name: "extension 4",
        'for': [anySegment()],
        hold: function(s, n){
          return s.extend(0).isTrivial && s.extendToLength(0).isTrivial;
        }
      }, {
        name: "extend-to 1",
        run: function(){
          return segment([1, 1], [2, 3]).extendTo(Ox);
        },
        result: ray([1, 1], [2, 3])
      }, {
        name: "extend-to 2",
        'for': [anySegment(), anyLine()],
        hold: function(s, l){
          var h;
          h = s.extendTo(l);
          if (h instanceof Segment) {
            return l.isContaining(h.end);
          } else {
            return h instanceof Ray;
          }
        }
      }, {
        name: "extend-to 3",
        'for': [anyPoint(), anySegment()],
        assuming: [
          function(p, s){
            return s.isNontrivial;
          }, function(p, s){
            return !s.extension.isContaining(p);
          }
        ],
        hold: function(p, s){
          var a, c;
          a = Angle.azimuth(p, s.start);
          c = new Segment().at(p).atAngle(a).extendTo(s);
          return c instanceof Segment && c.end.isEqual(s.start);
        }
      }, {
        name: "height-to 1",
        'for': [anySegment(), anyRay()],
        'with': function(s, r){
          return [s, r, s.heightTo(r)];
        },
        hold: function(s, r, h){
          if (h instanceof Segment) {
            return r.isContaining(h.end);
          } else {
            return h instanceof Ray;
          }
        }
      }, {
        name: "height-to 2",
        'for': [anySegment(), anyLine('l')],
        assuming: [function(s, l){
          return s.isNontrivial && l.isNontrivial;
        }],
        'with': function(s, l){
          return [s, l, s.heightTo(l).label('h')];
        },
        hold: function(s, l, h){
          return h instanceof Segment && l.isContaining(h.end);
        }
      }, {
        name: "tangent-to 1",
        'for': [anyPoint(), anyCircle()],
        'with': function(p, c){
          var t1, t2;
          t1 = new Segment().at(p).tangentTo(c, 1);
          t2 = new Segment().at(p).tangentTo(c, -1);
          return [p, c, t1, t2];
        },
        hold: function(p, c, t1, t2){
          return t1.vector.dot(c.tangentV(c.locus(t1.end))) > 0 && t2.vector.dot(c.tangentV(c.locus(t2.end))) < 0;
        },
        assuming: [function(p, c){
          return c.isNontrivial && !c.isEnclosing(p);
        }]
      }, {
        name: "tangent-to 2",
        'for': [anyCircle(), anyParam()],
        'with': function(c, x){
          var p, t1, t2;
          p = c.point(x);
          t1 = new Segment().at(p).tangentTo(c, 1);
          t2 = new Segment().at(p).tangentTo(c, -1);
          return [c, x, t1, t2, p];
        },
        hold: function(c, x, t1, t2){
          return t1.vector.dot(c.tangentV(x)) > 0 && t2.vector.dot(c.tangentV(x)) < 0;
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }, {
        name: "tangent-to 3",
        'for': [anyPoint(), anyCircle()],
        'with': function(p, c){
          return [p, c, new Segment().at(p).tangentTo(c)];
        },
        hold: function(p, c, t){
          return t.isParallelTo(c.tangent(c.locus(t.end)));
        },
        assuming: [function(p, c){
          return c.isNontrivial && !c.isEnclosing(p);
        }]
      }, {
        name: "tangent-to 4",
        'for': [anyPoint(), anyCircle()],
        'with': function(p, c){
          var t;
          t = new Segment().at(p).tangentTo(c);
          return [p, c, t];
        },
        hold: function(p, c, t, i){
          return c.isContaining(t.end) && new Line().at(t.end).perpendicularTo(t).isContaining(c.center);
        },
        assuming: [function(p, c){
          return c.isNontrivial && !c.isEnclosing(p);
        }]
      }, {
        name: "tangent-to 5",
        'for': [anyCircle(), anyParam()],
        'with': function(c, x){
          return [c, x, new Segment().at(c.point(x)).tangentTo(c)];
        },
        hold: function(c, x, t){
          return t.isPerpendicularTo(c.radius(x));
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }, {
        name: 'trigonometry',
        'for': [anyParam(0, 1 / 4)],
        'with': function(x){
          var C, r, A, s, c, t, ct, phi;
          C = new Circle(10);
          r = C.radius(x);
          A = C.point(x);
          s = new Segment('sin').at(A).heightTo(Ox);
          c = new Segment('cos').at(A).heightTo(Oy);
          t = new Segment('tan').at(A).tangentTo(C, -1).extendTo(Ox);
          ct = new Segment('cot').at(A).tangentTo(C, 1).extendTo(Oy);
          phi = deg2rad(Angle.azimuth(origin, A));
          return [phi, s, c, t, ct, r, C, Ox, Oy];
        },
        hold: function(phi, s, c, t, ct, r){
          return equal(s.length / r.length, sin(phi)) && equal(c.length / r.length, cos(phi)) && equal(t.length / r.length, tan(phi)) && equal(ct.length / r.length, ctg(phi));
        },
        assuming: [function(x){
          return 0 < x && x < 1 / 4;
        }],
        number: 100
      }
    ]
  };
  testGroup = {
    name: 'Group',
    suite: []
  };
  testIntersections = {
    name: 'Intersections',
    suite: []
  };
  testAngles = {
    name: 'Angle',
    suite: [
      {
        name: "modulus",
        'for': [anyAngleValue()],
        hold: function(a){
          return equal(mod(-a, 360), mod(360 - a, 360));
        }
      }, {
        name: "isomorphism 1",
        'for': [anyXY()],
        hold: function(v){
          return equal(cross(Angle.iso(Angle.iso(v).angle).vector, v.normalize()), 0);
        }
      }, {
        name: "isomorphism 2",
        'for': [anyAngleValue()],
        hold: function(a){
          return equalMod(360, Angle.iso(Angle.iso(a).vector).angle, a);
        }
      }, {
        name: "copy 1",
        'for': [anyAngle()],
        hold: function(a){
          return a.copy().isEqual(a);
        }
      }, {
        name: "equal 1",
        'for': [anyAngle()],
        hold: function(a){
          return a.isEqual(a);
        }
      }, {
        name: "equal 2",
        'for': [anyAngle(), anyNum()],
        assuming: [function(a, x){
          return x > 0;
        }],
        hold: function(a, x){
          return a.scaleAt(a.vertex, x).isEqual(a);
        }
      }, {
        name: "equal 3",
        'for': [anyAngle(), anyNum()],
        assuming: [function(a, x){
          return x > 0;
        }],
        hold: function(a, x){
          return a.rotate(a.vertex, x).isEqual(a);
        }
      }, {
        name: "isContaining",
        suite: [
          {
            name: '1',
            run: function(){
              return !new Angle(30).isContaining(40);
            }
          }, {
            name: '2',
            run: function(){
              return new Angle(30).isContaining(10);
            }
          }, {
            name: '4',
            run: function(){
              return new Angle(30).isContaining(0);
            }
          }, {
            name: '5',
            run: function(){
              return new Angle(30).isContaining(30);
            }
          }, {
            name: '6',
            run: function(){
              return !new Angle(30).rotate(45).isContaining(30);
            }
          }, {
            name: '7',
            run: function(){
              return new Angle(30).rotate(45).isContaining(70);
            }
          }, {
            name: '8',
            run: function(){
              return !new Angle(30).rotate(-45).isContaining(0);
            }
          }, {
            name: '9',
            run: function(){
              return new Angle(30).rotate(-20).isContaining(0);
            }
          }, {
            name: '9',
            run: function(){
              return new Angle(30).rotate(340).isContaining(0);
            }
          }, {
            name: '10',
            run: function(){
              return new Angle(30).reflectAt([0, 0]).isContaining(200);
            }
          }, {
            name: '11',
            run: function(){
              return !new Angle(30).reflectAt([0, 0]).isContaining(170);
            }
          }
        ]
      }
    ]
  };
  testCircle = {
    name: 'Circle',
    suite: [
      {
        name: 'IntersectionL 1',
        'for': [anyCircle(), anyLine()],
        assuming: [function(c, l){
          return c.isNontrivial && l.isNontrivial;
        }],
        'with': function(c, l){
          return [c, l, c.intersectionL(l), c.center.distance(l)];
        },
        hold: function(c, l, i, d){
          switch (compare(d, c.R)) {
          case 'GT':
            return i.length === 0;
          case 'EQ':
            return i.length === 1;
          case 'LT':
            return i.length === 2;
          }
        }
      }, {
        name: 'isomorphism 1',
        'for': [anyCircle(), anyParam()],
        hold: function(c, t){
          return equal(c.locus(c.point(t)), t);
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }, {
        name: 'isomorphism 2',
        'for': [anyCircle(), anyParam()],
        'with': function(c, t){
          return [c, c.point(t), t];
        },
        hold: function(c, p){
          return equal(c.point(c.locus(p)), p);
        },
        assuming: [function(c){
          return c.isNontrivial;
        }]
      }, {
        name: 'radius',
        suite: [
          {
            name: '1',
            run: function(){
              return new Circle(3).radius(0).end;
            },
            result: point([3, 0])
          }, {
            name: '2',
            run: function(){
              return new Circle(3).radius(0.5).end;
            },
            result: point([-3, 0])
          }, {
            name: '3',
            run: function(){
              return new Circle(3).radius(0.25).end;
            },
            result: point([0, 3])
          }, {
            name: '4',
            run: function(){
              return new Circle(3).radius(1).end;
            },
            result: point([3, 0])
          }
        ]
      }, {
        name: 'tangent',
        suite: [
          {
            name: '1',
            run: function(){
              return new Circle(3).tangentV(0);
            },
            result: [0, 1]
          }, {
            name: '2',
            run: function(){
              return new Circle(3).tangentV(1 / 2);
            },
            result: [0, -1]
          }, {
            name: '3',
            run: function(){
              return new Circle(3).tangentV(1 / 4);
            },
            result: [-1, 0]
          }, {
            name: '4',
            run: function(){
              return new Circle(3).tangentV(1 / 8);
            },
            result: [-1, 1].normalize()
          }, {
            name: '5',
            run: function(){
              return new Circle(3).tangentV(1);
            },
            result: [0, 1]
          }
        ]
      }
    ]
  };
  testPolygon = {
    name: 'Polygon',
    suite: []
  };
  testSquare = {
    name: 'Square',
    suite: []
  };
  allTests = {
    number: 25,
    log: true,
    suite: [testTests, testPoints, testLines, testRays, testSegments, testIntersections, testAngles, testPolygon, testSquare, testCircle]
  };
  console.log('Running tests...');
  runTests(allTests);
  console.log('Testing done');
}).call(this);
