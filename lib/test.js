// Generated by LiveScript 1.6.0
(function(){
  var labeled, anyParam, anyXY, anyPoint, anyAngle, anyLine, anySegment, anyRay, anyRadius, anyCircle, triangle, anyTriangle, testTests, testPoints, testTransformations, testLines, allTests;
  labeled = function(l){
    return function(f){
      return function(){
        var x, res$, i$, to$;
        res$ = [];
        for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
          res$.push(arguments[i$]);
        }
        x = res$;
        if (l) {
          return f.apply(null, x).label(l);
        } else {
          return f.apply(null, x);
        }
      };
    };
  };
  anyParam = function(a, b){
    a == null && (a = 0);
    b == null && (b = 1);
    return anyNum().range(a, b).precision(0.01).ascending();
  };
  anyXY = function(){
    return ArbitraryCoordinates();
  };
  anyPoint = function(l){
    return args(anyXY()).iso(labeled(l)(point), function(p){
      return [p.xy];
    });
  };
  anyAngle = function(){
    return anyNum().range(0, 360).precision(1);
  };
  anyLine = function(l){
    return args(anyPoint(), anyPoint()).iso(labeled(l)(line), function(l){
      return [l.point(0), l.point(1)];
    });
  };
  anySegment = function(l){
    return args(anyPoint(), anyPoint()).iso(labeled(l)(segment), function(l){
      return [l.point(0), l.point(1)];
    });
  };
  anyRay = function(l){
    return args(anyPoint(), anyAngle()).iso(labeled(l)(ray), function(r){
      return [r.start, r.angle(0)];
    });
  };
  anyRadius = function(){
    return anyNum().range(1, paperSize / 4).precision(1).ascending();
  };
  anyCircle = function(){
    return args(anyPoint(), anyRadius()).iso(circle, function(c){
      return [c.center, c.R];
    }).ascending();
  };
  triangle = function(a, b, c){
    return new Triangle(a, b, c);
  };
  anyTriangle = function(){
    return args(anyPoint(), anyPoint(), anyPoint()).iso(triangle, function(c){
      return c.vertices;
    }).filter(function(t){
      return t.isNontrivial;
    });
  };
  testTests = {
    name: 'Tests',
    skip: true,
    log: true,
    suite: [
      {
        name: "1",
        'for': anyNum().range(0, 100).precision(0.1),
        hold: function(n){
          return n === 4;
        },
        number: 10
      }, {
        name: "2",
        'for': [anyNum(), anyNum()],
        hold: function(n, m){
          return n >= m;
        },
        log: false
      }, {
        name: "3",
        'for': [anyCircle(), anyPoint()],
        assuming: function(c, p){
          return c.R > 1 && c.center.isNotEqual(p);
        },
        hold: function(c, p){
          return !c.isEnclosing(p);
        }
      }, {
        name: "tangentTo 2",
        'for': [anyCircle(), anyParam()],
        'with': function(c, x){
          return [c, x, new Line().at(c.point(x)).tangentTo(c), c.radius(x)];
        },
        hold: function(c, x, t){
          return t.isPerpendicularTo(c.radius(x));
        },
        assuming: function(c){
          return c.isNontrivial;
        }
      }, {
        name: 'trigonometry',
        'for': anyParam(0, 1 / 4),
        'with': function(x){
          var C, r, A, s, c, t, ct, phi;
          C = new Circle(10);
          r = C.radius(x);
          A = C.point(x);
          s = new Segment('sin').at(A).heightTo(Ox);
          c = new Segment('cos').at(A).heightTo(Oy);
          t = new Segment('tan').at(A).tangentTo(C, 1).extendTo(Ox);
          ct = new Segment('cot').at(A).tangentTo(C, -1).extendTo(Oy);
          phi = deg2rad(Angle.azimuth(origin, A));
          return [phi, s, c, t, ct, r, C, Ox, Oy];
        },
        hold: function(phi, s, c, t, ct, r){
          return equal(s.length / r.length, sin(phi)) && equal(c.length / r.length, cos(phi)) && equal(t.length / r.length, tg(phi)) && equal(ct.length / r.length, ctg(phi));
        },
        assuming: [function(x){
          return x > 0.1 && x < 0.2;
        }]
      }
    ]
  };
  testPoints = {
    name: 'Points',
    number: 10,
    suite: [
      {
        name: "isomorphism 1",
        'for': [anyPoint()],
        holds: function(p){
          return Point.iso(Point.iso(p).xy).point.isEqual(p);
        }
      }, {
        name: "copy 1",
        run: function(){
          return point([3, 4]).copy();
        },
        result: point([3, 4])
      }, {
        name: "superpose",
        'for': [anyPoint(), anyPoint()],
        holds: function(p1, p2){
          return p1.superpose(p1, p2).isEqual(p2);
        }
      }, {
        name: "isomorphism 1",
        'for': [anyPoint()],
        hold: function(p){
          return Point.iso(Point.iso(p).xy).point.isEqual(p);
        }
      }, {
        name: "isomorphism 2",
        'for': [anyXY()],
        hold: function(xy){
          return equal(Point.iso(Point.iso(xy).point).xy, xy);
        }
      }, {
        name: "copy 1",
        'for': [anyPoint()],
        hold: function(p){
          return p.copy().isEqual(p);
        }
      }, {
        name: "coordinates 1",
        'for': [anyPoint()],
        hold: function(p){
          return origin.at(p).isEqual(point(p));
        }
      }, {
        name: "equality 1",
        'for': [anyPoint()],
        hold: function(p){
          return p.isEqual(p);
        }
      }, {
        name: "equality 2",
        'for': [anyPoint()],
        hold: function(p){
          return point(p.xy).isEqual(p);
        }
      }, {
        name: "equality 3",
        'for': [anyPoint()],
        hold: function(p){
          return !p.copy().translate([1, 1]).isEqual(p);
        }
      }, {
        name: "translate 1",
        run: function(){
          return new Point().translate([1, 2]).xy;
        },
        result: [1, 2]
      }
    ]
  };
  testTransformations = {
    name: 'Transformations',
    suite: []
  };
  testLines = {
    name: 'Lines',
    suite: [{
      number: 10,
      suite: [
        {
          name: "isomorphism 1",
          'for': [anyLine(), anyNum()],
          assuming: [function(l){
            return l.isNontrivial;
          }],
          hold: function(l, s){
            return equal(l.locus(l.point(s)), s);
          }
        }, {
          name: "isomorphism 2",
          'for': [anyPoint(), anyNum()],
          where: function(p, s){
            return [l, s];
          },
          hold: function(p, s){
            var l;
            l = line(p, p);
            return l.isTrivial && equal(l.locus(l.point(s)), 0);
          }
        }
      ]
    }]
  };
  allTests = {
    number: 50,
    log: true,
    suite: [testTests, testPoints, testLines]
  };
  console.log('Running tests...');
  runTests(allTests);
  console.log('Testing done');
}).call(this);
