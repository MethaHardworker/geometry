<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: /home/sergey/work/webinar/webfigs/lib/geometry.js</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html"></a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="Angle">
            <span class="title">
                <a href="Angle.html">Angle</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Angle#box"><a href="Angle.html#box">box</a></li>
            
                <li data-name="Angle#boxHeight"><a href="Angle.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Angle#boxWidth"><a href="Angle.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Angle#isLabeled"><a href="Angle.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Angle#refPoint"><a href="Angle.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Angle#above"><a href="Angle.html#above">above</a></li>
            
                <li data-name="Angle#align"><a href="Angle.html#align">align</a></li>
            
                <li data-name="Angle#at"><a href="Angle.html#at">at</a></li>
            
                <li data-name="Angle#below"><a href="Angle.html#below">below</a></li>
            
                <li data-name="Angle#beside"><a href="Angle.html#beside">beside</a></li>
            
                <li data-name="Angle#boxAlign"><a href="Angle.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Angle#boxCorner"><a href="Angle.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Angle#color"><a href="Angle.html#color">color</a></li>
            
                <li data-name="Angle#copy"><a href="Angle.html#copy">copy</a></li>
            
                <li data-name="Angle#dashed"><a href="Angle.html#dashed">dashed</a></li>
            
                <li data-name="Angle#dotted"><a href="Angle.html#dotted">dotted</a></li>
            
                <li data-name="Angle#isEqual"><a href="Angle.html#isEqual">isEqual</a></li>
            
                <li data-name="Angle#isSimilar"><a href="Angle.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Angle#label"><a href="Angle.html#label">label</a></li>
            
                <li data-name="Angle#lineStyle"><a href="Angle.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Angle#option"><a href="Angle.html#option">option</a></li>
            
                <li data-name="Angle#pointStyle"><a href="Angle.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Angle#reflect"><a href="Angle.html#reflect">reflect</a></li>
            
                <li data-name="Angle#reflectAt"><a href="Angle.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Angle#rotate"><a href="Angle.html#rotate">rotate</a></li>
            
                <li data-name="Angle#rotateAt"><a href="Angle.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Angle#scale"><a href="Angle.html#scale">scale</a></li>
            
                <li data-name="Angle#scaleAt"><a href="Angle.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Angle#stretch"><a href="Angle.html#stretch">stretch</a></li>
            
                <li data-name="Angle#stretchAt"><a href="Angle.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Angle#superpose"><a href="Angle.html#superpose">superpose</a></li>
            
                <li data-name="Angle#thin"><a href="Angle.html#thin">thin</a></li>
            
                <li data-name="Angle#transform"><a href="Angle.html#transform">transform</a></li>
            
                <li data-name="Angle#translate"><a href="Angle.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="BoxedFigure">
            <span class="title">
                <a href="BoxedFigure.html">BoxedFigure</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="BoxedFigure#box"><a href="BoxedFigure.html#box">box</a></li>
            
                <li data-name="BoxedFigure#boxHeight"><a href="BoxedFigure.html#boxHeight">boxHeight</a></li>
            
                <li data-name="BoxedFigure#boxWidth"><a href="BoxedFigure.html#boxWidth">boxWidth</a></li>
            
                <li data-name="BoxedFigure#isLabeled"><a href="BoxedFigure.html#isLabeled">isLabeled</a></li>
            
                <li data-name="BoxedFigure#refPoint"><a href="BoxedFigure.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="BoxedFigure#above"><a href="BoxedFigure.html#above">above</a></li>
            
                <li data-name="BoxedFigure#align"><a href="BoxedFigure.html#align">align</a></li>
            
                <li data-name="BoxedFigure#at"><a href="BoxedFigure.html#at">at</a></li>
            
                <li data-name="BoxedFigure#below"><a href="BoxedFigure.html#below">below</a></li>
            
                <li data-name="BoxedFigure#beside"><a href="BoxedFigure.html#beside">beside</a></li>
            
                <li data-name="BoxedFigure#boxAlign"><a href="BoxedFigure.html#boxAlign">boxAlign</a></li>
            
                <li data-name="BoxedFigure#boxCorner"><a href="BoxedFigure.html#boxCorner">boxCorner</a></li>
            
                <li data-name="BoxedFigure#color"><a href="BoxedFigure.html#color">color</a></li>
            
                <li data-name="BoxedFigure#copy"><a href="BoxedFigure.html#copy">copy</a></li>
            
                <li data-name="BoxedFigure#dashed"><a href="BoxedFigure.html#dashed">dashed</a></li>
            
                <li data-name="BoxedFigure#dotted"><a href="BoxedFigure.html#dotted">dotted</a></li>
            
                <li data-name="BoxedFigure#isEqual"><a href="BoxedFigure.html#isEqual">isEqual</a></li>
            
                <li data-name="BoxedFigure#isSimilar"><a href="BoxedFigure.html#isSimilar">isSimilar</a></li>
            
                <li data-name="BoxedFigure#label"><a href="BoxedFigure.html#label">label</a></li>
            
                <li data-name="BoxedFigure#lineStyle"><a href="BoxedFigure.html#lineStyle">lineStyle</a></li>
            
                <li data-name="BoxedFigure#option"><a href="BoxedFigure.html#option">option</a></li>
            
                <li data-name="BoxedFigure#pointStyle"><a href="BoxedFigure.html#pointStyle">pointStyle</a></li>
            
                <li data-name="BoxedFigure#reflect"><a href="BoxedFigure.html#reflect">reflect</a></li>
            
                <li data-name="BoxedFigure#reflectAt"><a href="BoxedFigure.html#reflectAt">reflectAt</a></li>
            
                <li data-name="BoxedFigure#rotate"><a href="BoxedFigure.html#rotate">rotate</a></li>
            
                <li data-name="BoxedFigure#rotateAt"><a href="BoxedFigure.html#rotateAt">rotateAt</a></li>
            
                <li data-name="BoxedFigure#scale"><a href="BoxedFigure.html#scale">scale</a></li>
            
                <li data-name="BoxedFigure#scaleAt"><a href="BoxedFigure.html#scaleAt">scaleAt</a></li>
            
                <li data-name="BoxedFigure#stretch"><a href="BoxedFigure.html#stretch">stretch</a></li>
            
                <li data-name="BoxedFigure#stretchAt"><a href="BoxedFigure.html#stretchAt">stretchAt</a></li>
            
                <li data-name="BoxedFigure#superpose"><a href="BoxedFigure.html#superpose">superpose</a></li>
            
                <li data-name="BoxedFigure#thin"><a href="BoxedFigure.html#thin">thin</a></li>
            
                <li data-name="BoxedFigure#transform"><a href="BoxedFigure.html#transform">transform</a></li>
            
                <li data-name="BoxedFigure#translate"><a href="BoxedFigure.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Chart">
            <span class="title">
                <a href="Chart.html">Chart</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Circle">
            <span class="title">
                <a href="Circle.html">Circle</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Circle#box"><a href="Circle.html#box">box</a></li>
            
                <li data-name="Circle#boxHeight"><a href="Circle.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Circle#boxWidth"><a href="Circle.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Circle#isLabeled"><a href="Circle.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Circle#refPoint"><a href="Circle.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Circle#above"><a href="Circle.html#above">above</a></li>
            
                <li data-name="Circle#align"><a href="Circle.html#align">align</a></li>
            
                <li data-name="Circle#at"><a href="Circle.html#at">at</a></li>
            
                <li data-name="Circle#below"><a href="Circle.html#below">below</a></li>
            
                <li data-name="Circle#beside"><a href="Circle.html#beside">beside</a></li>
            
                <li data-name="Circle#boxAlign"><a href="Circle.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Circle#boxCorner"><a href="Circle.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Circle#color"><a href="Circle.html#color">color</a></li>
            
                <li data-name="Circle#copy"><a href="Circle.html#copy">copy</a></li>
            
                <li data-name="Circle#dashed"><a href="Circle.html#dashed">dashed</a></li>
            
                <li data-name="Circle#dotted"><a href="Circle.html#dotted">dotted</a></li>
            
                <li data-name="Circle#isEqual"><a href="Circle.html#isEqual">isEqual</a></li>
            
                <li data-name="Circle#isSimilar"><a href="Circle.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Circle#label"><a href="Circle.html#label">label</a></li>
            
                <li data-name="Circle#lineStyle"><a href="Circle.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Circle#option"><a href="Circle.html#option">option</a></li>
            
                <li data-name="Circle#pointStyle"><a href="Circle.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Circle#reflect"><a href="Circle.html#reflect">reflect</a></li>
            
                <li data-name="Circle#reflectAt"><a href="Circle.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Circle#rotate"><a href="Circle.html#rotate">rotate</a></li>
            
                <li data-name="Circle#rotateAt"><a href="Circle.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Circle#scale"><a href="Circle.html#scale">scale</a></li>
            
                <li data-name="Circle#scaleAt"><a href="Circle.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Circle#stretch"><a href="Circle.html#stretch">stretch</a></li>
            
                <li data-name="Circle#stretchAt"><a href="Circle.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Circle#superpose"><a href="Circle.html#superpose">superpose</a></li>
            
                <li data-name="Circle#thin"><a href="Circle.html#thin">thin</a></li>
            
                <li data-name="Circle#transform"><a href="Circle.html#transform">transform</a></li>
            
                <li data-name="Circle#translate"><a href="Circle.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Curve">
            <span class="title">
                <a href="Curve.html">Curve</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Curve#box"><a href="Curve.html#box">box</a></li>
            
                <li data-name="Curve#boxHeight"><a href="Curve.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Curve#boxWidth"><a href="Curve.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Curve#isLabeled"><a href="Curve.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Curve#refPoint"><a href="Curve.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Curve#above"><a href="Curve.html#above">above</a></li>
            
                <li data-name="Curve#align"><a href="Curve.html#align">align</a></li>
            
                <li data-name="Curve#at"><a href="Curve.html#at">at</a></li>
            
                <li data-name="Curve#below"><a href="Curve.html#below">below</a></li>
            
                <li data-name="Curve#beside"><a href="Curve.html#beside">beside</a></li>
            
                <li data-name="Curve#boxAlign"><a href="Curve.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Curve#boxCorner"><a href="Curve.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Curve#color"><a href="Curve.html#color">color</a></li>
            
                <li data-name="Curve#copy"><a href="Curve.html#copy">copy</a></li>
            
                <li data-name="Curve#dashed"><a href="Curve.html#dashed">dashed</a></li>
            
                <li data-name="Curve#dotted"><a href="Curve.html#dotted">dotted</a></li>
            
                <li data-name="Curve#isEqual"><a href="Curve.html#isEqual">isEqual</a></li>
            
                <li data-name="Curve#isSimilar"><a href="Curve.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Curve#label"><a href="Curve.html#label">label</a></li>
            
                <li data-name="Curve#lineStyle"><a href="Curve.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Curve#option"><a href="Curve.html#option">option</a></li>
            
                <li data-name="Curve#pointStyle"><a href="Curve.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Curve#reflect"><a href="Curve.html#reflect">reflect</a></li>
            
                <li data-name="Curve#reflectAt"><a href="Curve.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Curve#rotate"><a href="Curve.html#rotate">rotate</a></li>
            
                <li data-name="Curve#rotateAt"><a href="Curve.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Curve#scale"><a href="Curve.html#scale">scale</a></li>
            
                <li data-name="Curve#scaleAt"><a href="Curve.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Curve#stretch"><a href="Curve.html#stretch">stretch</a></li>
            
                <li data-name="Curve#stretchAt"><a href="Curve.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Curve#superpose"><a href="Curve.html#superpose">superpose</a></li>
            
                <li data-name="Curve#thin"><a href="Curve.html#thin">thin</a></li>
            
                <li data-name="Curve#transform"><a href="Curve.html#transform">transform</a></li>
            
                <li data-name="Curve#translate"><a href="Curve.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Figure">
            <span class="title">
                <a href="Figure.html">Figure</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Figure#isLabeled"><a href="Figure.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Figure#refPoint"><a href="Figure.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Figure#align"><a href="Figure.html#align">align</a></li>
            
                <li data-name="Figure#at"><a href="Figure.html#at">at</a></li>
            
                <li data-name="Figure#color"><a href="Figure.html#color">color</a></li>
            
                <li data-name="Figure#copy"><a href="Figure.html#copy">copy</a></li>
            
                <li data-name="Figure#dashed"><a href="Figure.html#dashed">dashed</a></li>
            
                <li data-name="Figure#dotted"><a href="Figure.html#dotted">dotted</a></li>
            
                <li data-name="Figure#isEqual"><a href="Figure.html#isEqual">isEqual</a></li>
            
                <li data-name="Figure#isSimilar"><a href="Figure.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Figure#label"><a href="Figure.html#label">label</a></li>
            
                <li data-name="Figure#lineStyle"><a href="Figure.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Figure#option"><a href="Figure.html#option">option</a></li>
            
                <li data-name="Figure#pointStyle"><a href="Figure.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Figure#reflect"><a href="Figure.html#reflect">reflect</a></li>
            
                <li data-name="Figure#reflectAt"><a href="Figure.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Figure#rotate"><a href="Figure.html#rotate">rotate</a></li>
            
                <li data-name="Figure#rotateAt"><a href="Figure.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Figure#scale"><a href="Figure.html#scale">scale</a></li>
            
                <li data-name="Figure#scaleAt"><a href="Figure.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Figure#stretch"><a href="Figure.html#stretch">stretch</a></li>
            
                <li data-name="Figure#stretchAt"><a href="Figure.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Figure#superpose"><a href="Figure.html#superpose">superpose</a></li>
            
                <li data-name="Figure#thin"><a href="Figure.html#thin">thin</a></li>
            
                <li data-name="Figure#transform"><a href="Figure.html#transform">transform</a></li>
            
                <li data-name="Figure#translate"><a href="Figure.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Group">
            <span class="title">
                <a href="Group.html">Group</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Group#box"><a href="Group.html#box">box</a></li>
            
                <li data-name="Group#boxHeight"><a href="Group.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Group#boxWidth"><a href="Group.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Group#isLabeled"><a href="Group.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Group#refPoint"><a href="Group.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Group#above"><a href="Group.html#above">above</a></li>
            
                <li data-name="Group#align"><a href="Group.html#align">align</a></li>
            
                <li data-name="Group#at"><a href="Group.html#at">at</a></li>
            
                <li data-name="Group#below"><a href="Group.html#below">below</a></li>
            
                <li data-name="Group#beside"><a href="Group.html#beside">beside</a></li>
            
                <li data-name="Group#boxAlign"><a href="Group.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Group#boxCorner"><a href="Group.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Group#color"><a href="Group.html#color">color</a></li>
            
                <li data-name="Group#copy"><a href="Group.html#copy">copy</a></li>
            
                <li data-name="Group#dashed"><a href="Group.html#dashed">dashed</a></li>
            
                <li data-name="Group#dotted"><a href="Group.html#dotted">dotted</a></li>
            
                <li data-name="Group#isEqual"><a href="Group.html#isEqual">isEqual</a></li>
            
                <li data-name="Group#isSimilar"><a href="Group.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Group#label"><a href="Group.html#label">label</a></li>
            
                <li data-name="Group#lineStyle"><a href="Group.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Group#option"><a href="Group.html#option">option</a></li>
            
                <li data-name="Group#pointStyle"><a href="Group.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Group#randomPoints"><a href="Group.html#randomPoints">randomPoints</a></li>
            
                <li data-name="Group#reflect"><a href="Group.html#reflect">reflect</a></li>
            
                <li data-name="Group#reflectAt"><a href="Group.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Group#rotate"><a href="Group.html#rotate">rotate</a></li>
            
                <li data-name="Group#rotateAt"><a href="Group.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Group#scale"><a href="Group.html#scale">scale</a></li>
            
                <li data-name="Group#scaleAt"><a href="Group.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Group#stretch"><a href="Group.html#stretch">stretch</a></li>
            
                <li data-name="Group#stretchAt"><a href="Group.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Group#superpose"><a href="Group.html#superpose">superpose</a></li>
            
                <li data-name="Group#thin"><a href="Group.html#thin">thin</a></li>
            
                <li data-name="Group#transform"><a href="Group.html#transform">transform</a></li>
            
                <li data-name="Group#translate"><a href="Group.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Line">
            <span class="title">
                <a href="Line.html">Line</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Line#box"><a href="Line.html#box">box</a></li>
            
                <li data-name="Line#boxHeight"><a href="Line.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Line#boxWidth"><a href="Line.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Line#isLabeled"><a href="Line.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Line#refPoint"><a href="Line.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Line#above"><a href="Line.html#above">above</a></li>
            
                <li data-name="Line#align"><a href="Line.html#align">align</a></li>
            
                <li data-name="Line#at"><a href="Line.html#at">at</a></li>
            
                <li data-name="Line#below"><a href="Line.html#below">below</a></li>
            
                <li data-name="Line#beside"><a href="Line.html#beside">beside</a></li>
            
                <li data-name="Line#boxAlign"><a href="Line.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Line#boxCorner"><a href="Line.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Line#color"><a href="Line.html#color">color</a></li>
            
                <li data-name="Line#copy"><a href="Line.html#copy">copy</a></li>
            
                <li data-name="Line#dashed"><a href="Line.html#dashed">dashed</a></li>
            
                <li data-name="Line#dotted"><a href="Line.html#dotted">dotted</a></li>
            
                <li data-name="Line#isEqual"><a href="Line.html#isEqual">isEqual</a></li>
            
                <li data-name="Line#isSimilar"><a href="Line.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Line#label"><a href="Line.html#label">label</a></li>
            
                <li data-name="Line#lineStyle"><a href="Line.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Line#option"><a href="Line.html#option">option</a></li>
            
                <li data-name="Line#pointStyle"><a href="Line.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Line#reflect"><a href="Line.html#reflect">reflect</a></li>
            
                <li data-name="Line#reflectAt"><a href="Line.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Line#rotate"><a href="Line.html#rotate">rotate</a></li>
            
                <li data-name="Line#rotateAt"><a href="Line.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Line#scale"><a href="Line.html#scale">scale</a></li>
            
                <li data-name="Line#scaleAt"><a href="Line.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Line#stretch"><a href="Line.html#stretch">stretch</a></li>
            
                <li data-name="Line#stretchAt"><a href="Line.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Line#superpose"><a href="Line.html#superpose">superpose</a></li>
            
                <li data-name="Line#thin"><a href="Line.html#thin">thin</a></li>
            
                <li data-name="Line#transform"><a href="Line.html#transform">transform</a></li>
            
                <li data-name="Line#translate"><a href="Line.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Point">
            <span class="title">
                <a href="Point.html">Point</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Point#box"><a href="Point.html#box">box</a></li>
            
                <li data-name="Point#boxHeight"><a href="Point.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Point#boxWidth"><a href="Point.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Point#isLabeled"><a href="Point.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Point#refPoint"><a href="Point.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Point#above"><a href="Point.html#above">above</a></li>
            
                <li data-name="Point#align"><a href="Point.html#align">align</a></li>
            
                <li data-name="Point#at"><a href="Point.html#at">at</a></li>
            
                <li data-name="Point#below"><a href="Point.html#below">below</a></li>
            
                <li data-name="Point#beside"><a href="Point.html#beside">beside</a></li>
            
                <li data-name="Point#boxAlign"><a href="Point.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Point#boxCorner"><a href="Point.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Point#color"><a href="Point.html#color">color</a></li>
            
                <li data-name="Point#copy"><a href="Point.html#copy">copy</a></li>
            
                <li data-name="Point#dashed"><a href="Point.html#dashed">dashed</a></li>
            
                <li data-name="Point#dotted"><a href="Point.html#dotted">dotted</a></li>
            
                <li data-name="Point#isEqual"><a href="Point.html#isEqual">isEqual</a></li>
            
                <li data-name="Point#isSimilar"><a href="Point.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Point#label"><a href="Point.html#label">label</a></li>
            
                <li data-name="Point#lineStyle"><a href="Point.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Point#option"><a href="Point.html#option">option</a></li>
            
                <li data-name="Point#pointStyle"><a href="Point.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Point#reflect"><a href="Point.html#reflect">reflect</a></li>
            
                <li data-name="Point#reflectAt"><a href="Point.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Point#rotate"><a href="Point.html#rotate">rotate</a></li>
            
                <li data-name="Point#rotateAt"><a href="Point.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Point#scale"><a href="Point.html#scale">scale</a></li>
            
                <li data-name="Point#scaleAt"><a href="Point.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Point#stretch"><a href="Point.html#stretch">stretch</a></li>
            
                <li data-name="Point#stretchAt"><a href="Point.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Point#superpose"><a href="Point.html#superpose">superpose</a></li>
            
                <li data-name="Point#thin"><a href="Point.html#thin">thin</a></li>
            
                <li data-name="Point#transform"><a href="Point.html#transform">transform</a></li>
            
                <li data-name="Point#translate"><a href="Point.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Polygon">
            <span class="title">
                <a href="Polygon.html">Polygon</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Polygon#box"><a href="Polygon.html#box">box</a></li>
            
                <li data-name="Polygon#boxHeight"><a href="Polygon.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Polygon#boxWidth"><a href="Polygon.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Polygon#isLabeled"><a href="Polygon.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Polygon#refPoint"><a href="Polygon.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Polygon#above"><a href="Polygon.html#above">above</a></li>
            
                <li data-name="Polygon#align"><a href="Polygon.html#align">align</a></li>
            
                <li data-name="Polygon#at"><a href="Polygon.html#at">at</a></li>
            
                <li data-name="Polygon#below"><a href="Polygon.html#below">below</a></li>
            
                <li data-name="Polygon#beside"><a href="Polygon.html#beside">beside</a></li>
            
                <li data-name="Polygon#boxAlign"><a href="Polygon.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Polygon#boxCorner"><a href="Polygon.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Polygon#color"><a href="Polygon.html#color">color</a></li>
            
                <li data-name="Polygon#copy"><a href="Polygon.html#copy">copy</a></li>
            
                <li data-name="Polygon#dashed"><a href="Polygon.html#dashed">dashed</a></li>
            
                <li data-name="Polygon#dotted"><a href="Polygon.html#dotted">dotted</a></li>
            
                <li data-name="Polygon#isEqual"><a href="Polygon.html#isEqual">isEqual</a></li>
            
                <li data-name="Polygon#isSimilar"><a href="Polygon.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Polygon#label"><a href="Polygon.html#label">label</a></li>
            
                <li data-name="Polygon#lineStyle"><a href="Polygon.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Polygon#option"><a href="Polygon.html#option">option</a></li>
            
                <li data-name="Polygon#pointStyle"><a href="Polygon.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Polygon#reflect"><a href="Polygon.html#reflect">reflect</a></li>
            
                <li data-name="Polygon#reflectAt"><a href="Polygon.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Polygon#rotate"><a href="Polygon.html#rotate">rotate</a></li>
            
                <li data-name="Polygon#rotateAt"><a href="Polygon.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Polygon#scale"><a href="Polygon.html#scale">scale</a></li>
            
                <li data-name="Polygon#scaleAt"><a href="Polygon.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Polygon#stretch"><a href="Polygon.html#stretch">stretch</a></li>
            
                <li data-name="Polygon#stretchAt"><a href="Polygon.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Polygon#superpose"><a href="Polygon.html#superpose">superpose</a></li>
            
                <li data-name="Polygon#thin"><a href="Polygon.html#thin">thin</a></li>
            
                <li data-name="Polygon#transform"><a href="Polygon.html#transform">transform</a></li>
            
                <li data-name="Polygon#translate"><a href="Polygon.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Quadrilateral">
            <span class="title">
                <a href="Quadrilateral.html">Quadrilateral</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Quadrilateral#box"><a href="Quadrilateral.html#box">box</a></li>
            
                <li data-name="Quadrilateral#boxHeight"><a href="Quadrilateral.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Quadrilateral#boxWidth"><a href="Quadrilateral.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Quadrilateral#isLabeled"><a href="Quadrilateral.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Quadrilateral#refPoint"><a href="Quadrilateral.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Quadrilateral#above"><a href="Quadrilateral.html#above">above</a></li>
            
                <li data-name="Quadrilateral#align"><a href="Quadrilateral.html#align">align</a></li>
            
                <li data-name="Quadrilateral#at"><a href="Quadrilateral.html#at">at</a></li>
            
                <li data-name="Quadrilateral#below"><a href="Quadrilateral.html#below">below</a></li>
            
                <li data-name="Quadrilateral#beside"><a href="Quadrilateral.html#beside">beside</a></li>
            
                <li data-name="Quadrilateral#boxAlign"><a href="Quadrilateral.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Quadrilateral#boxCorner"><a href="Quadrilateral.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Quadrilateral#color"><a href="Quadrilateral.html#color">color</a></li>
            
                <li data-name="Quadrilateral#copy"><a href="Quadrilateral.html#copy">copy</a></li>
            
                <li data-name="Quadrilateral#dashed"><a href="Quadrilateral.html#dashed">dashed</a></li>
            
                <li data-name="Quadrilateral#dotted"><a href="Quadrilateral.html#dotted">dotted</a></li>
            
                <li data-name="Quadrilateral#isEqual"><a href="Quadrilateral.html#isEqual">isEqual</a></li>
            
                <li data-name="Quadrilateral#isSimilar"><a href="Quadrilateral.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Quadrilateral#label"><a href="Quadrilateral.html#label">label</a></li>
            
                <li data-name="Quadrilateral#lineStyle"><a href="Quadrilateral.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Quadrilateral#option"><a href="Quadrilateral.html#option">option</a></li>
            
                <li data-name="Quadrilateral#pointStyle"><a href="Quadrilateral.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Quadrilateral#reflect"><a href="Quadrilateral.html#reflect">reflect</a></li>
            
                <li data-name="Quadrilateral#reflectAt"><a href="Quadrilateral.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Quadrilateral#rotate"><a href="Quadrilateral.html#rotate">rotate</a></li>
            
                <li data-name="Quadrilateral#rotateAt"><a href="Quadrilateral.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Quadrilateral#scale"><a href="Quadrilateral.html#scale">scale</a></li>
            
                <li data-name="Quadrilateral#scaleAt"><a href="Quadrilateral.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Quadrilateral#stretch"><a href="Quadrilateral.html#stretch">stretch</a></li>
            
                <li data-name="Quadrilateral#stretchAt"><a href="Quadrilateral.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Quadrilateral#superpose"><a href="Quadrilateral.html#superpose">superpose</a></li>
            
                <li data-name="Quadrilateral#thin"><a href="Quadrilateral.html#thin">thin</a></li>
            
                <li data-name="Quadrilateral#transform"><a href="Quadrilateral.html#transform">transform</a></li>
            
                <li data-name="Quadrilateral#translate"><a href="Quadrilateral.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Ray">
            <span class="title">
                <a href="Ray.html">Ray</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Ray#box"><a href="Ray.html#box">box</a></li>
            
                <li data-name="Ray#boxHeight"><a href="Ray.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Ray#boxWidth"><a href="Ray.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Ray#isLabeled"><a href="Ray.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Ray#refPoint"><a href="Ray.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Ray#above"><a href="Ray.html#above">above</a></li>
            
                <li data-name="Ray#align"><a href="Ray.html#align">align</a></li>
            
                <li data-name="Ray#at"><a href="Ray.html#at">at</a></li>
            
                <li data-name="Ray#below"><a href="Ray.html#below">below</a></li>
            
                <li data-name="Ray#beside"><a href="Ray.html#beside">beside</a></li>
            
                <li data-name="Ray#boxAlign"><a href="Ray.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Ray#boxCorner"><a href="Ray.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Ray#color"><a href="Ray.html#color">color</a></li>
            
                <li data-name="Ray#copy"><a href="Ray.html#copy">copy</a></li>
            
                <li data-name="Ray#dashed"><a href="Ray.html#dashed">dashed</a></li>
            
                <li data-name="Ray#dotted"><a href="Ray.html#dotted">dotted</a></li>
            
                <li data-name="Ray#isEqual"><a href="Ray.html#isEqual">isEqual</a></li>
            
                <li data-name="Ray#isSimilar"><a href="Ray.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Ray#label"><a href="Ray.html#label">label</a></li>
            
                <li data-name="Ray#lineStyle"><a href="Ray.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Ray#option"><a href="Ray.html#option">option</a></li>
            
                <li data-name="Ray#pointStyle"><a href="Ray.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Ray#reflect"><a href="Ray.html#reflect">reflect</a></li>
            
                <li data-name="Ray#reflectAt"><a href="Ray.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Ray#rotate"><a href="Ray.html#rotate">rotate</a></li>
            
                <li data-name="Ray#rotateAt"><a href="Ray.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Ray#scale"><a href="Ray.html#scale">scale</a></li>
            
                <li data-name="Ray#scaleAt"><a href="Ray.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Ray#stretch"><a href="Ray.html#stretch">stretch</a></li>
            
                <li data-name="Ray#stretchAt"><a href="Ray.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Ray#superpose"><a href="Ray.html#superpose">superpose</a></li>
            
                <li data-name="Ray#thin"><a href="Ray.html#thin">thin</a></li>
            
                <li data-name="Ray#transform"><a href="Ray.html#transform">transform</a></li>
            
                <li data-name="Ray#translate"><a href="Ray.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Rectangle">
            <span class="title">
                <a href="Rectangle.html">Rectangle</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Rectangle#box"><a href="Rectangle.html#box">box</a></li>
            
                <li data-name="Rectangle#boxHeight"><a href="Rectangle.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Rectangle#boxWidth"><a href="Rectangle.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Rectangle#isLabeled"><a href="Rectangle.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Rectangle#refPoint"><a href="Rectangle.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Rectangle#above"><a href="Rectangle.html#above">above</a></li>
            
                <li data-name="Rectangle#align"><a href="Rectangle.html#align">align</a></li>
            
                <li data-name="Rectangle#at"><a href="Rectangle.html#at">at</a></li>
            
                <li data-name="Rectangle#below"><a href="Rectangle.html#below">below</a></li>
            
                <li data-name="Rectangle#beside"><a href="Rectangle.html#beside">beside</a></li>
            
                <li data-name="Rectangle#boxAlign"><a href="Rectangle.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Rectangle#boxCorner"><a href="Rectangle.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Rectangle#color"><a href="Rectangle.html#color">color</a></li>
            
                <li data-name="Rectangle#copy"><a href="Rectangle.html#copy">copy</a></li>
            
                <li data-name="Rectangle#dashed"><a href="Rectangle.html#dashed">dashed</a></li>
            
                <li data-name="Rectangle#dotted"><a href="Rectangle.html#dotted">dotted</a></li>
            
                <li data-name="Rectangle#isEqual"><a href="Rectangle.html#isEqual">isEqual</a></li>
            
                <li data-name="Rectangle#isSimilar"><a href="Rectangle.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Rectangle#label"><a href="Rectangle.html#label">label</a></li>
            
                <li data-name="Rectangle#lineStyle"><a href="Rectangle.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Rectangle#option"><a href="Rectangle.html#option">option</a></li>
            
                <li data-name="Rectangle#pointStyle"><a href="Rectangle.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Rectangle#reflect"><a href="Rectangle.html#reflect">reflect</a></li>
            
                <li data-name="Rectangle#reflectAt"><a href="Rectangle.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Rectangle#rotate"><a href="Rectangle.html#rotate">rotate</a></li>
            
                <li data-name="Rectangle#rotateAt"><a href="Rectangle.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Rectangle#scale"><a href="Rectangle.html#scale">scale</a></li>
            
                <li data-name="Rectangle#scaleAt"><a href="Rectangle.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Rectangle#stretch"><a href="Rectangle.html#stretch">stretch</a></li>
            
                <li data-name="Rectangle#stretchAt"><a href="Rectangle.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Rectangle#superpose"><a href="Rectangle.html#superpose">superpose</a></li>
            
                <li data-name="Rectangle#thin"><a href="Rectangle.html#thin">thin</a></li>
            
                <li data-name="Rectangle#transform"><a href="Rectangle.html#transform">transform</a></li>
            
                <li data-name="Rectangle#translate"><a href="Rectangle.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Scale">
            <span class="title">
                <a href="Scale.html">Scale</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Scale#box"><a href="Scale.html#box">box</a></li>
            
                <li data-name="Scale#boxHeight"><a href="Scale.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Scale#boxWidth"><a href="Scale.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Scale#isLabeled"><a href="Scale.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Scale#refPoint"><a href="Scale.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Scale#above"><a href="Scale.html#above">above</a></li>
            
                <li data-name="Scale#align"><a href="Scale.html#align">align</a></li>
            
                <li data-name="Scale#at"><a href="Scale.html#at">at</a></li>
            
                <li data-name="Scale#below"><a href="Scale.html#below">below</a></li>
            
                <li data-name="Scale#beside"><a href="Scale.html#beside">beside</a></li>
            
                <li data-name="Scale#boxAlign"><a href="Scale.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Scale#boxCorner"><a href="Scale.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Scale#color"><a href="Scale.html#color">color</a></li>
            
                <li data-name="Scale#copy"><a href="Scale.html#copy">copy</a></li>
            
                <li data-name="Scale#dashed"><a href="Scale.html#dashed">dashed</a></li>
            
                <li data-name="Scale#dotted"><a href="Scale.html#dotted">dotted</a></li>
            
                <li data-name="Scale#isEqual"><a href="Scale.html#isEqual">isEqual</a></li>
            
                <li data-name="Scale#isSimilar"><a href="Scale.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Scale#label"><a href="Scale.html#label">label</a></li>
            
                <li data-name="Scale#lineStyle"><a href="Scale.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Scale#option"><a href="Scale.html#option">option</a></li>
            
                <li data-name="Scale#pointStyle"><a href="Scale.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Scale#reflect"><a href="Scale.html#reflect">reflect</a></li>
            
                <li data-name="Scale#reflectAt"><a href="Scale.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Scale#rotate"><a href="Scale.html#rotate">rotate</a></li>
            
                <li data-name="Scale#rotateAt"><a href="Scale.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Scale#scale"><a href="Scale.html#scale">scale</a></li>
            
                <li data-name="Scale#scaleAt"><a href="Scale.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Scale#stretch"><a href="Scale.html#stretch">stretch</a></li>
            
                <li data-name="Scale#stretchAt"><a href="Scale.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Scale#superpose"><a href="Scale.html#superpose">superpose</a></li>
            
                <li data-name="Scale#thin"><a href="Scale.html#thin">thin</a></li>
            
                <li data-name="Scale#transform"><a href="Scale.html#transform">transform</a></li>
            
                <li data-name="Scale#translate"><a href="Scale.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Segment">
            <span class="title">
                <a href="Segment.html">Segment</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Segment#box"><a href="Segment.html#box">box</a></li>
            
                <li data-name="Segment#boxHeight"><a href="Segment.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Segment#boxWidth"><a href="Segment.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Segment#isLabeled"><a href="Segment.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Segment#refPoint"><a href="Segment.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Segment#above"><a href="Segment.html#above">above</a></li>
            
                <li data-name="Segment#align"><a href="Segment.html#align">align</a></li>
            
                <li data-name="Segment#at"><a href="Segment.html#at">at</a></li>
            
                <li data-name="Segment#below"><a href="Segment.html#below">below</a></li>
            
                <li data-name="Segment#beside"><a href="Segment.html#beside">beside</a></li>
            
                <li data-name="Segment#boxAlign"><a href="Segment.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Segment#boxCorner"><a href="Segment.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Segment#color"><a href="Segment.html#color">color</a></li>
            
                <li data-name="Segment#copy"><a href="Segment.html#copy">copy</a></li>
            
                <li data-name="Segment#dashed"><a href="Segment.html#dashed">dashed</a></li>
            
                <li data-name="Segment#dotted"><a href="Segment.html#dotted">dotted</a></li>
            
                <li data-name="Segment#isEqual"><a href="Segment.html#isEqual">isEqual</a></li>
            
                <li data-name="Segment#isSimilar"><a href="Segment.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Segment#label"><a href="Segment.html#label">label</a></li>
            
                <li data-name="Segment#lineStyle"><a href="Segment.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Segment#option"><a href="Segment.html#option">option</a></li>
            
                <li data-name="Segment#pointStyle"><a href="Segment.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Segment#reflect"><a href="Segment.html#reflect">reflect</a></li>
            
                <li data-name="Segment#reflectAt"><a href="Segment.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Segment#rotate"><a href="Segment.html#rotate">rotate</a></li>
            
                <li data-name="Segment#rotateAt"><a href="Segment.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Segment#scale"><a href="Segment.html#scale">scale</a></li>
            
                <li data-name="Segment#scaleAt"><a href="Segment.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Segment#stretch"><a href="Segment.html#stretch">stretch</a></li>
            
                <li data-name="Segment#stretchAt"><a href="Segment.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Segment#superpose"><a href="Segment.html#superpose">superpose</a></li>
            
                <li data-name="Segment#thin"><a href="Segment.html#thin">thin</a></li>
            
                <li data-name="Segment#transform"><a href="Segment.html#transform">transform</a></li>
            
                <li data-name="Segment#translate"><a href="Segment.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Square">
            <span class="title">
                <a href="Square.html">Square</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Square#box"><a href="Square.html#box">box</a></li>
            
                <li data-name="Square#boxHeight"><a href="Square.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Square#boxWidth"><a href="Square.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Square#isLabeled"><a href="Square.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Square#refPoint"><a href="Square.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Square#above"><a href="Square.html#above">above</a></li>
            
                <li data-name="Square#align"><a href="Square.html#align">align</a></li>
            
                <li data-name="Square#at"><a href="Square.html#at">at</a></li>
            
                <li data-name="Square#below"><a href="Square.html#below">below</a></li>
            
                <li data-name="Square#beside"><a href="Square.html#beside">beside</a></li>
            
                <li data-name="Square#boxAlign"><a href="Square.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Square#boxCorner"><a href="Square.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Square#color"><a href="Square.html#color">color</a></li>
            
                <li data-name="Square#copy"><a href="Square.html#copy">copy</a></li>
            
                <li data-name="Square#dashed"><a href="Square.html#dashed">dashed</a></li>
            
                <li data-name="Square#dotted"><a href="Square.html#dotted">dotted</a></li>
            
                <li data-name="Square#isEqual"><a href="Square.html#isEqual">isEqual</a></li>
            
                <li data-name="Square#isSimilar"><a href="Square.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Square#label"><a href="Square.html#label">label</a></li>
            
                <li data-name="Square#lineStyle"><a href="Square.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Square#option"><a href="Square.html#option">option</a></li>
            
                <li data-name="Square#pointStyle"><a href="Square.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Square#reflect"><a href="Square.html#reflect">reflect</a></li>
            
                <li data-name="Square#reflectAt"><a href="Square.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Square#rotate"><a href="Square.html#rotate">rotate</a></li>
            
                <li data-name="Square#rotateAt"><a href="Square.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Square#scale"><a href="Square.html#scale">scale</a></li>
            
                <li data-name="Square#scaleAt"><a href="Square.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Square#stretch"><a href="Square.html#stretch">stretch</a></li>
            
                <li data-name="Square#stretchAt"><a href="Square.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Square#superpose"><a href="Square.html#superpose">superpose</a></li>
            
                <li data-name="Square#thin"><a href="Square.html#thin">thin</a></li>
            
                <li data-name="Square#transform"><a href="Square.html#transform">transform</a></li>
            
                <li data-name="Square#translate"><a href="Square.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Text">
            <span class="title">
                <a href="Text.html">Text</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Text#box"><a href="Text.html#box">box</a></li>
            
                <li data-name="Text#boxHeight"><a href="Text.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Text#boxWidth"><a href="Text.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Text#isLabeled"><a href="Text.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Text#refPoint"><a href="Text.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Text#above"><a href="Text.html#above">above</a></li>
            
                <li data-name="Text#align"><a href="Text.html#align">align</a></li>
            
                <li data-name="Text#at"><a href="Text.html#at">at</a></li>
            
                <li data-name="Text#below"><a href="Text.html#below">below</a></li>
            
                <li data-name="Text#beside"><a href="Text.html#beside">beside</a></li>
            
                <li data-name="Text#boxAlign"><a href="Text.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Text#boxCorner"><a href="Text.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Text#color"><a href="Text.html#color">color</a></li>
            
                <li data-name="Text#copy"><a href="Text.html#copy">copy</a></li>
            
                <li data-name="Text#dashed"><a href="Text.html#dashed">dashed</a></li>
            
                <li data-name="Text#dotted"><a href="Text.html#dotted">dotted</a></li>
            
                <li data-name="Text#isEqual"><a href="Text.html#isEqual">isEqual</a></li>
            
                <li data-name="Text#isSimilar"><a href="Text.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Text#label"><a href="Text.html#label">label</a></li>
            
                <li data-name="Text#lineStyle"><a href="Text.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Text#option"><a href="Text.html#option">option</a></li>
            
                <li data-name="Text#pointStyle"><a href="Text.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Text#reflect"><a href="Text.html#reflect">reflect</a></li>
            
                <li data-name="Text#reflectAt"><a href="Text.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Text#rotate"><a href="Text.html#rotate">rotate</a></li>
            
                <li data-name="Text#rotateAt"><a href="Text.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Text#scale"><a href="Text.html#scale">scale</a></li>
            
                <li data-name="Text#scaleAt"><a href="Text.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Text#stretch"><a href="Text.html#stretch">stretch</a></li>
            
                <li data-name="Text#stretchAt"><a href="Text.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Text#superpose"><a href="Text.html#superpose">superpose</a></li>
            
                <li data-name="Text#thin"><a href="Text.html#thin">thin</a></li>
            
                <li data-name="Text#transform"><a href="Text.html#transform">transform</a></li>
            
                <li data-name="Text#translate"><a href="Text.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Triangle">
            <span class="title">
                <a href="Triangle.html">Triangle</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Triangle#box"><a href="Triangle.html#box">box</a></li>
            
                <li data-name="Triangle#boxHeight"><a href="Triangle.html#boxHeight">boxHeight</a></li>
            
                <li data-name="Triangle#boxWidth"><a href="Triangle.html#boxWidth">boxWidth</a></li>
            
                <li data-name="Triangle#isLabeled"><a href="Triangle.html#isLabeled">isLabeled</a></li>
            
                <li data-name="Triangle#refPoint"><a href="Triangle.html#refPoint">refPoint</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Triangle#above"><a href="Triangle.html#above">above</a></li>
            
                <li data-name="Triangle#align"><a href="Triangle.html#align">align</a></li>
            
                <li data-name="Triangle#at"><a href="Triangle.html#at">at</a></li>
            
                <li data-name="Triangle#below"><a href="Triangle.html#below">below</a></li>
            
                <li data-name="Triangle#beside"><a href="Triangle.html#beside">beside</a></li>
            
                <li data-name="Triangle#boxAlign"><a href="Triangle.html#boxAlign">boxAlign</a></li>
            
                <li data-name="Triangle#boxCorner"><a href="Triangle.html#boxCorner">boxCorner</a></li>
            
                <li data-name="Triangle#color"><a href="Triangle.html#color">color</a></li>
            
                <li data-name="Triangle#copy"><a href="Triangle.html#copy">copy</a></li>
            
                <li data-name="Triangle#dashed"><a href="Triangle.html#dashed">dashed</a></li>
            
                <li data-name="Triangle#dotted"><a href="Triangle.html#dotted">dotted</a></li>
            
                <li data-name="Triangle#isEqual"><a href="Triangle.html#isEqual">isEqual</a></li>
            
                <li data-name="Triangle#isSimilar"><a href="Triangle.html#isSimilar">isSimilar</a></li>
            
                <li data-name="Triangle#label"><a href="Triangle.html#label">label</a></li>
            
                <li data-name="Triangle#lineStyle"><a href="Triangle.html#lineStyle">lineStyle</a></li>
            
                <li data-name="Triangle#option"><a href="Triangle.html#option">option</a></li>
            
                <li data-name="Triangle#pointStyle"><a href="Triangle.html#pointStyle">pointStyle</a></li>
            
                <li data-name="Triangle#reflect"><a href="Triangle.html#reflect">reflect</a></li>
            
                <li data-name="Triangle#reflectAt"><a href="Triangle.html#reflectAt">reflectAt</a></li>
            
                <li data-name="Triangle#rotate"><a href="Triangle.html#rotate">rotate</a></li>
            
                <li data-name="Triangle#rotateAt"><a href="Triangle.html#rotateAt">rotateAt</a></li>
            
                <li data-name="Triangle#scale"><a href="Triangle.html#scale">scale</a></li>
            
                <li data-name="Triangle#scaleAt"><a href="Triangle.html#scaleAt">scaleAt</a></li>
            
                <li data-name="Triangle#stretch"><a href="Triangle.html#stretch">stretch</a></li>
            
                <li data-name="Triangle#stretchAt"><a href="Triangle.html#stretchAt">stretchAt</a></li>
            
                <li data-name="Triangle#superpose"><a href="Triangle.html#superpose">superpose</a></li>
            
                <li data-name="Triangle#thin"><a href="Triangle.html#thin">thin</a></li>
            
                <li data-name="Triangle#transform"><a href="Triangle.html#transform">transform</a></li>
            
                <li data-name="Triangle#translate"><a href="Triangle.html#translate">translate</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="-_home_sergey_work_webinar_webfigs_lib_geometry.js.html">Source: /home/sergey/work/webinar/webfigs/lib/geometry.js</h1>
        


    
    <section>
        <article>
            <pre id="source-code" class="prettyprint source "><code>/** A pair of numbers, representing a vector.
 * @typedef {Pair&lt;Number>} XY
 * @example
 * [2, 3]
 */

/** A matrix as a list of list
 * @typedef {Array&lt;Array&lt;Number>>} Matrix
 * @example
 * [[2, 0, 0],[0, 3, 0],[0, 0, 1]
 */

/** An object representing CSS style
 * @typedef {Object} Style
 * @example
 * {'stroke':'red', 'stroke-opacity':0.5}
 */

/** Representation of a boundeng box
 * @typedef {Pair&lt;XY>} Box
 * @example
 * new Circle(2).box 
 * > [[-2,-2],[2,2]]
 */

/** Representation of a postion within a bounding box. sign ∈ {-1, 0, 1}
 * @typedef {sign} AlignmentIndex 
 * @example
 * new Circle(2).beside(new Square(), -1) // aligned at bottomline 
 * new Circle(2).beside(new Square(), 0) // aligned at centerline
 * new Circle(2).beside(new Square(), 1) // aligned at topline
 */



const paperSize = 50
const xRange = [-paperSize/2,paperSize/2]
const yRange = [-paperSize/2,paperSize/2]

const style = {
    svg : {
	'background':'#333'
    },

    point : {
	'stroke':'#333',
	'stroke-width':1,
	'fill':'red'
    },

    line : {
	'stroke':'orange',
	'stroke-width':2,
	'fill':'none'
    },
    
    polygon : {
	'stroke':'orange',
	'stroke-width':2,
	'fill':'none'
    },

    circle : {
	'stroke':'orange',
	'stroke-width':2,
	'fill':'none'
    },
    
    angle : {
	'stroke':'wheat',
	'stroke-width':1.5,
	'fill':'none'
    },
    
    label : {
	'font-family' : "'CMU Serif', serif",
	'font-style' : 'italic',
	'font-size' : '18px',
	'fill':'wheat',
    },
    
    text : {
	'font-family' : "'CMU Sans Serif', sans-serif",
	'font-style' : 'italic',
	'font-size' : '18px',
	'fill':'wheat',
    }
}

////////////////////////////////////////////////////////////
// math

function isXY (obj) {
    return (obj instanceof Array)
	&amp;&amp; obj.length == 2
	&amp;&amp; obj.every(Number.isFinite)
}

function pointOrXY (pos) {
    console.assert(pos instanceof Point || isXY(pos),
		  "pointOrXY: position shoud be either Point or coordinates")
    if (pos instanceof Point)
	return {point: pos, xy : pos.xy}
    else
	return {point: point(pos), xy:pos}
}

function angleV(vector) {
    // tested
    const x = vector[0], y = vector[1]
    if (x == 0 &amp;&amp; y == 0) return 0
    if (x == 1 &amp;&amp; y == 0) return 0
    if (x == 0 &amp;&amp; y == 1) return 90
    if (x == -1 &amp;&amp; y == 0) return 180
    if (x == 0 &amp;&amp; y == -1) return 270
    const a = rad2deg(Math.atan(y/x))
    if (x >= 0 &amp;&amp; y >= 0) return a
    if (x &lt;= 0 &amp;&amp; y >= 0) return 180 + a
    if (x &lt;= 0 &amp;&amp; y &lt; 0) return 180 + a
    if (x > 0 &amp;&amp; y &lt;= 0) return 360 + a
    return a
}

function lineEquation([x1, y1], [x2, y2], scale = 1) {
    // tested
    const v = [x2 - x1, y2 - y1]
    return t => point([x1, y1].vadd(v.scale(t*scale)))
}

function intersectionV([x1, y1], [v1x, v1y], [x2, y2], [v2x, v2y]) {
    // tested
    const D = v1y*v2x - v1x*v2y,
	  D1 = v1x*y1 - v1y*x1,
	  D2 = v2y*x2 - v2x*y2
    if (D == 0) return [1/0, 1/0]
    return [-(v1x*D2 + v2x*D1)/D, -(v1y*D2 + v2y*D1)/D]
}

function cross([x1, y1], [x2, y2]) {
    return x1*y2 - x2*y1
}

function rot90([x, y]) { return [-y, x] }

function naturalParametrization(pts, type = 'infinite') {
    if (pts.length == 0 || !type)
	return {'eqn': undefined, length : undefined}
    
    let ls, xs, ys, res
    if (type == 'closed') {
	ls = pts.rotatel().zipWith(pts, (a,b) => a.vsub(b).norm()).accumsum();
	[xs,ys] = pts.concat([pts[0]]).transpose()
    }
    else {
	ls = pts.tail().zipWith(pts, (a,b) => a.vsub(b).norm()).accumsum();
	[xs,ys] = pts.transpose()
    }
    let l = ls.last()
    let sls = ls.scale(1/l)
    let X = linearInterpolation([sls, xs].transpose())
    let Y = linearInterpolation([sls, ys].transpose())

    if (type == 'closed')
	res = s => [X(mod(s, 1)), Y(mod(s, 1))]
    else
	res = s => [X(s), Y(s)]

    return {'eqn': res, 'length': l, pointLocations: sls }
}

function differential (f) {
    const ds = 1e-8
    return s => f(s+ds).vsub(f(s-ds)).scale(1/(2*ds))
}

function vector (point1, point2) {
    return point2.xy.vsub(point1.xy)
}

const augment = ([x, y]) => [x, y, 1] 
const pure = ([x, y, _]) => [x, y] 
const trans = (T, v)  => pure(vmul(T, augment(v))) 
const rotT  = a => [[cos(a), -sin(a), 0], [sin(a), cos(a), 0], [0, 0, 1]]
const reflectT = a => [[cos(2*a), sin(2*a), 0], [sin(2*a), -cos(2*a), 0], [0, 0, 1]] 
const translateT = ([dx, dy]) => [[1, 0, dx], [0, 1, dy], [0, 0, 1]] 
const scaleT  = (a, b) => [[a, 0, 0], [0, b, 0], [0, 0, 1]] 

// Box

function appendBox (box1, box2) {
    return [[min(box1[0][0], box2[0][0]), min(box1[0][1],box2[0][1])]
	    ,[max(box1[1][0], box2[1][0]), max(box1[1][1],box2[1][1])]]
}

const Box = {mappend: appendBox,
	     mempty: [[Infinity,Infinity],[-Infinity,-Infinity]]}


////////////////////////////////////////////////////////////
// Figure and transformations
/** Abstract class representing a geometric figure.
 * Provides basic linear transformations.
 */
class Figure {
    constructor (label) {
	this.options = {
	    'label' : label
	}
    }

    /** Makes functional copy of an object.
     * @return {Figure} a copy of a caller
     */
    copy (obj = null) {
	if (!obj) {
	    let res = new Figure()
	    Object.assign(res.options, this.options)
	    return res
	} else {
	    Object.assign(this.options, obj.options)
	    return this
	}
    }

    /** Object fields equivalence.
     * @abstract 
     * @return {bool}
     */
    isEqual (obj) { return this == obj }

    /** Geometric equivalence.
     * @abstract 
     * @return {bool}
     */
    isSimilar (obj) { return this.isEqual(obj) }
    
    /** General linear transformation. Returns a copy of the figure.
     * @abstract 
     * @param {Matrix} T the 3×3 transformation matrix
     * @return {Figure} a copy of a caller
     */
    transform (T) {
	console.error("transform is unimplemented")
    }

    /** The refference point of a figure. Used for superposition of figures.
     * @abstract 
     * @return {Point}
     */
    get refPoint () { return point([0,0]) }
    
    /** Transformation. Locates refference point of a figure at given position.
     * @return {Figure} a copy of a caller
     * @param {Point | XY} pos
     */
    at (pos) {
	return this.superpose(this.refPoint, pointOrXY(pos).point)
    }

    /** Transformation. Parallel translation along a given vector.
     * @return {Figure} a copy of a caller
     * @param {XY} vector
     */
    translate(vector) {
	return this.transform(translateT(vector))
    }
    
    /** Transformation. Scaling along the axis.
     * @return {Figure} a copy of a caller
     * @param {Number} xscale
     * @param {Number} [yscale = xscale]
     */
    scale(xscale, yscale = xscale) {
	return this.transform(scaleT(xscale, yscale))
    }

    /** Transformation. Scaling along the axis at a given point.
     * @return {Figure} a copy of a caller
     * @param {Point|XY} pos
     * @param {Number} xscale
     * @param {Number} [yscale = xscale]
     */
    scaleAt(pos, xscale, yscale = xscale) {
	const pt = pointOrXY(pos).xy
	return this.translate(pt.flip()).scale(xscale, yscale).translate(pt)
    }

    /** Transformation. Stretching along the given line, ray or segment.
     * @return {Figure} a copy of a caller
     * @param {Line} line
     * @param {Number} scale
     */
    stretch(line, scale) {
	return this.rotate(-line.angle(0)).scale(1,scale).rotate(line.angle(0))
    }

    /** Transformation. Stretching along the given line, ray or segment at a given point.
     * @return {Figure} a copy of a caller
     * @param {Point | XY} pos
     * @param {Line|Ray|Segment} line
     * @param {Number} scale
     */
    stretchAt(point, line, scale) {
	const pt = pointOrXY(pos).xy
	return this.translate(pt.flip()).stretch(line, scale).translate(pt)
    }

    /** Transformation. Translation resulting in the superposition of two given points.
     * @return {Figure} a copy of a caller
     * @param {Point | XY} pnt1 moving point
     * @param {Point | XY} pnt2 fixed point
     */
    superpose(pnt1, pnt2) {
	return this.translate(line(pnt1, pnt2).vector)
    }

    /** Transformation. Translation and rotation resulting in the superposition of two given lines, rays or segments.
     * @return {Figure} a copy of a caller
     * @param {Line|Ray|Segment} line1 moving line
     * @param {Line|Ray|Segment} line2 fixed line
     */
    align(line1, line2) {
	// tested Point
	return this.rotateAt(line1.point(0), line2.angle(0) - line1.angle(0))
    }

    /** Transformation. Rotation around the origin.
     * @return {Figure} a copy of a caller
     * @param {angle} ang angle counting CCW
     */
    rotate(ang) {
	return this.transform(rotT(deg2rad(ang)))
    }

    /** Transformation. Rotation around the given point.
     * @return {Figure} a copy of a caller
     * @param {Point|XY} pos 
     * @param {angle} ang angle counting CCW
     */
    rotateAt(pos, ang) {
	const pt = pointOrXY(pos).xy
	return this.translate(pt.flip()).rotate(ang).translate(pt)
    }

    /** Transformation. Reflection against the axis passing through the origin at given angle.
     * @return {Figure} a copy of a caller
     * @param {angle} ang angle counting CCW
     */
    reflect (ang) {
	return this.transform(reflectT(deg2rad(ang)))
    }
    
    /** Transformation. Reflection against the given point or line. If a point is given then central reflection is performed. If a line is given then axial reflection is done.
     * @return {Figure} a copy of a caller
     * @param {Point|Line|Ray|Segment} point_or_line
     */
    reflectAt(point_or_line) {
	const that = point_or_line

	console.assert(that instanceof Point || that instanceof Line,
		       'reflection could be done against Point or Line')

	if (that instanceof Point) {
	    return this.scaleAt(that,-1)
	}
	if (that instanceof Line) {
	    const b = that.angle(0),
		  pt = that.pivot
	    return this.translate(pt.flip()).reflect(b).translate(pt)
	}	
	return this
    }

    /** Unpure. Sets or returns the option of an object.
     * @return {Any} option value or a Figure with new option setting.
     * @param {String} option
     * @param {Any} [value = null]
     */
    option (opt, x = null) {
	if (x === null) {
	    return this.options[opt]
	} else {
	    this.options[opt] = x
	    return this
	}
    }
    
    /** Unpure. Sets or returns the label of an object.
     * @return {String|Figure} label or a Figure with new leabel.
     * @param {String} [value = null]
     */
    label (l = null) {
	if (l === null )
	    return this.option('label')
	else
	    return this.option('label', l)
    }

    /** Predicate. Returns true if Figure has a label.
     * @return {bool}
     */
    get isLabeled () { return !!this.options['label'] }

    /** Sets a style of lines for a figure.
     * @return {Figure} a copy of a caller
     * @param {Style} style
     */
    lineStyle (style) {
	const res = this.copy(),
	      st = Object.assign({}, res.options['line-style']),
	      ls = Object.assign(st,style)
	return res.option('line-style', ls)
    }

    /** Sets a style of points for a figure.
     * @return {Figure} a copy of a caller
     * @param {Style} style
     */
    pointStyle (attr, value) {
	const res = this.copy(),
	      st = Object.assign({}, res.options['point-style']),
	      s = {}
	s[attr] = value
	const ls = Object.assign(st,s)
	return res.option('point-style', ls)
    }

    /** Sets a dashed line
     * @return {Figure} a copy of a caller
     */
    dashed () {	return this.lineStyle({'stroke-dasharray':'5,5'}) }

    /** Sets a dotted line 
     * @return {Figure} a copy of a caller
     */
    dotted () {	return this.lineStyle({'stroke-dasharray':'2,4'}) }

    /** Sets thickness of lines
     * @return {Figure} a copy of a caller
     * @param {Number} [thickness = 1]
     */
    thin (th = 1) { return this.lineStyle({'stroke-width':th}) }

    /** Sets color of lines
     * @return {Figure} a copy of a caller
     * @param {String} color
     */
    color (c) {	return this.lineStyle({'stroke':c}) }
}

///////////////////////////////////////////////////////////
// Boxed
/** Abstract class representing bounding box information.
 * @extends Figure
 */
class BoxedFigure extends Figure {
    constructor (label) {
	super(label)
    }
    
    /** Returns a bounding box of a figure as a pair of the lower-left corner and the upper-right corner
     * @abstract
     * @type {Box}
     */
    get box () { return Box.mempty }
    
    /** Returns a width of a figure  */
    get boxWidth () {
	return 	this.boxCorner(-1,-1).distance(this.boxCorner(1,-1))
    }

    /** Returns a height of a figure  */
    get boxHeight () {
	return 	this.boxCorner(-1,-1).distance(this.boxCorner(-1,1))
    }
    
    /** Returns a location within a bounding box. Location is given by an index.
     * @return {Point}
     * @param {Pair&lt;Number>} location in form [dx, dy] where dx,dy ∈ [-1, 0, 1].
     * @example
     * let c = new Circle(2)
     * > c.boxCorner([-1,-1]).xy
     * [-2, 2]
     * > c.boxCorner([-1,0]).xy
     * [-2, 0]
     * > c.boxCorner([-1,1]).xy
     * [-2, 2]
     * > c.boxCorner([0,0]).xy
     * [0, 0]
     */
    boxCorner ([dx, dy]) {
	let xmin,ymin,xmax,ymax;
	[[xmin,ymin],[xmax,ymax]] = this.box
	const xs = [xmin, (xmin+xmax)/2, xmax],
	      ys = [ymin, (ymin+ymax)/2, ymax]
	return point([xs[1+Math.sign(dx)], ys[1+Math.sign(dy)]])
    }  
    
    /** Aligns two figures by superposing their boxCorners.
     * @return {Group}
     * @param {Pair&lt;Number>} bc1 caller's boxCorner
     * @param {BoxedFigure} obj object to be moved and aligned
     * @param {Pair&lt;Number>} bc2 moving object's boxCorner
     * @param {Pair&lt;Number>} [spacing = [0,0]] a pair of numbers giving horizontal 
     * and vertical spacing between figures
     */
    boxAlign (bc1, obj, bc2, spacing = [0,0]) {
	return new Group([
	    this,
	    obj.superpose(obj.boxCorner(bc1), this.boxCorner(bc2))
		.translate(spacing)
	])
    }

    /** Aligns two figures horizontally
     * @return {Group}
     * @param {BoxedFigure} obj object to be moved and aligned
     * @param {AlignmentIndex} alignment -1 — bottomline, 0 — centerline, 1 — topline
     * @param {Number} [spacing = 0] horizontal spacing between figures
     */
    beside(obj, alignment = 0, space = 0) {
	return this.boxAlign([-1, alignment], obj, [1, alignment], [space, 0]) 
    }

    /** Aligns two figures vertically.
     * @return {Group}
     * @param {BoxedFigure} obj object to be moved and aligned
     * @param {AlignmentIndex} alignment -1 — leftside, 0 — center, 1 — rightside
     * @param {Number} [spacing = 0] vertical spacing between figures
     */
    below(obj, alignment = 0, space = 0) {
	return this.boxAlign([alignment, -1], obj, [alignment, 1], [0, space]) 
    }

    /** Aligns two figures vertically.
     * @return {Group}
     * @param {BoxedFigure} obj object to be moved and aligned
     * @param {AlignmentIndex} alignment -1 — leftside, 0 — center, 1 — rightside
     * @param {Number} [spacing = 0] vertical spacing between figures
     */
    above(obj, alignment = 0, space = 0) {
	return this.boxAlign([alignment, 1], obj, [alignment, -1], [0, -space]) 
    }

}


///////////////////////////////////////////////////////////
// Group
/** Representing a group of figures
 * @extends BoxedFigure
 */
class Group extends BoxedFigure {
    constructor(figures) {
	super()
	this.contents = figures
    }

    //------------------------------------------------------------
    // Figure implementation

    /** Makes functional copy of all objects in a group.
     * @return {Group} a copy of a caller
     */
    copy () {
	const res = new Group()
	res.contents = this.contents.map(f => f.copy())
	return res
    }

    /** The refference point of a group (left-bottom corner of a bounding box). Used for superposition of figures.
     * @return {Point}
     */
    get refPoint () { return this.boxCorner([0,0]) }

    /** General linear transformation. Returns a copy of the group.
     * @param {Matrix} T the 3×3 transformation matrix
     * @return {Figure} a copy of a caller
     */
    transform (T) {
	const res = this.copy()
	res.contents = res.contents.map(f => f.transform(T))
	return res
    }

    //------------------------------------------------------------
    // Group methods

    element (i) {
	// tested
	return this.contents[(i - 1) % this.contents.length]
    }

    withContents (fn) {
	let res = this.copy()
	res.contents = fn(res.contents)
	return res
    }

    mapContents (fn) { this.withContents(c => c.map(fn)) }
    filterContents (fn) { this.withContents(c => c.filter(fn)) }

    flat() {
	let res = this.copy()
	res.contents = this.contents.mapappend(
	    f => f instanceof Group ? f.flat().contents : [f])
	return res	
    }
    
    static row(figures, alignment = 0, space = 0) {
	return figures
	    .foldr((el,res) => el.beside(res, alignment, space))
	    .flat()
    }

    static column(figures, alignment = 0, space = 0) {
	return figures
	    .foldr((el,res) => el.above(res, alignment, space))
	    .flat()
    }

    /** Returns a group of points randomly distributed in a unit circle.
     * @type {Group}
     * @param {Number} n the number of points
     * @example
     * new Group().randomPoints(20).scale(1,2).rotate(45) // points distributed in an ellipse
     */
    randomPoints(n) {
	let r = () => sqrt(Math.random()),
	    a = () => 2*pi*Math.random(),
	    res = range(n).map(() => ((a,r) => point([cos(a), sin(a)].scale(r)))(a(),r()))
	return new Group(res)
    }

    /** Returns a bounding box of a group as folding of all element boxes.
     * @type {Box}
     */
    get box () { return this.contents.foldMap(f => f.box, Box) }
    
    show (paper)
    {
	// tested
	this.contents.forEach(f => f.show(paper))
    }
}

////////////////////////////////////////////////////////////
// Point

/** Representing a group of figures
 * @extends BoxedFigure
 */
class Point extends BoxedFigure {
    constructor (label)
    {
	super(label)
	const defaults = {
	    'labelPosition': [0, 0],
	    'labelOffset': [0, 1],
	    'pointSize' : 3, 
	    'point-style': style.point,
	    'invisible' : false
	}
	this.options = Object.assign(defaults, this.options)
	this.xy = [0, 0]
    }

    //------------------------------------------------------------
    // Figure implementation

    copy () {
	// tested
	const res = new Point()
	Object.assign(res.options, this.options)
	res.xy = this.xy.copy()
	return res
    }
    
    transform (T) {
	// tested
	const res = this.copy()
	res.xy = trans(T, res.xy)
	return res
    }

    isEqual (obj) {
	// tested
	return (obj instanceof Point) &amp;&amp;
	    equal(this.xy, obj.xy)
    }

    get refPoint () { return point(this.xy) }

    at (pos) {
	const res = this.copy()	
	res.xy = pos instanceof Point ? pos.xy : pos
	return res
    }
    
    //------------------------------------------------------------
    // Point methods
    
    get x () { return this.xy[0] }
    get y () { return this.xy[1] }
        
    on (curve, t) {
	// tested
	console.assert(curve instanceof Curve,
		       'Point could be found on a Curve instance.')
	return this.at(curve.point(t).xy)
    }

    between (point1, point2, t = 1/2) {
	// tested
	return this.on(new Line().joining(point1, point2), t)
    }

    intersection (curve1, curve2, n = 0) {
	// tests on curves
	console.assert(curve1 instanceof Curve &amp;&amp; curve2 instanceof Curve,
		       'intersection of non vectors')

	return this.at(curve1.intersections(curve2)[n].xy)
    }

    azimuth (point1, angle1, point2, angle2) {
	// tested
	const s = new Line().joining(point1, point2)
	const s1 = new Line().through(point1).atAngle(s.angle(0) + angle1)
	const s2 = new Line().through(point2).atAngle(s.angle(0) + 180 - angle2)
	if (s1.isParallelTo(s2))
	    return this.at([1/0,1/0])
	else
	    return this.at(s1.intersections(s2)[0].xy)
    }
    
    distance (obj) {
	// tested
	if (obj instanceof Point)
	    return vector(this, obj).norm()
	if (obj instanceof Line) {
	    var h = new Segment().through(this).heightTo(obj)
	    if (obj.isContaining(h.end))
		return h.length
	    else if (obj instanceof Ray)
		return this.distance(obj.start)
	    else
		return [obj.start, obj.end].map(p => this.distance(p)).min()
	}
	if (obj instanceof Polygon)
	    return obj.sides.map(s => this.distance(s)).min()
	if (obj instanceof Circle)
	    return abs(this.distance(obj.center)-obj.R)
	return undefined
    }
    
    labelOffset (offset) {
	return this.option('labelOffset', offset.normalize().scale(1.2))
    }

    get box () { return [this.xy, this.xy] }

    get isVisible () {
	// tested
	return plane.isEnclosing(this)
    }

    invisible (f = true) {
	return this.option('invisible', f)
    }
    
    show (paper) {
	if (!(plane.isEnclosing(this))) return
	if (!this.options.invisible)
	    paper.listPlot([this.xy], this.options)
	
	if (this.isLabeled) {
	    const l = this.label()
	    const lp = this.xy.vadd([-0.3*l.length, -0.5])
	    mkLabel(paper, l, lp.vadd(this.option('labelOffset')))
	}	
    }
    
}

////////////////////////////////////////////////////////////
// Curve
/** Representing a curve
 * @extends BoxedFigure
 */
class Curve extends BoxedFigure {
    constructor (label) {
	super(label)
	this.type = undefined
	this.point = undefined
	this.equation = undefined
	this.length = undefined
    }

    // ------------------------------------------------------------
    // Figure implementation


    //------------------------------------------------------
    resetEquations (s) {
	// sets parametrization, equation and length
	console.error('resetEquations is not implemented')
    }

    location (point) {
	console.error('location is not implemented')
    }

    intersections (obj) {
	console.assert(obj instanceof Curve,
		       "Intersections could be found only for curves.")
	return undefined
    }

    flip() {
    	console.error('flip is not implemented')
    }
    
    //------------------------------------------------------

    closed () {
	let res = this.copy()
	res.type = 'closed'
	res.resetEquations()
	return res
    }

    tangentV (s) {
	var df = differential(t => this.point(t).xy)
	return df(s).normalize()
    }

    tangent (s) { return new Line().through(this.point(s), this.tangentV(s)) }
    
    normalV (s) { return rot90(this.tangentV(s).normalize()) }

    normal (s) { return new Line().through(this.point(s), this.normalV(s)) }
    
    angle (s) { return angleV(this.tangentV(s)) }

    isContaining (point) { return this.equation(point.xy) }

    isEnclosing (point) {
	return ray(point).intersections(this).length % 2 == 1
    }

    isIntersecting (obj) {
	return obj instanceof Curve
	    &amp;&amp; this.intersections(obj)
	    .some(p => this.isContaining(p) &amp;&amp; obj.isContaining(p))
    }

    get isClosed() { return this.type == 'closed' }
    get isFinite() { return this.type == 'finite' }

    pointClosestTo (obj){
	return this.point(findMinimum(x => obj.distance(this.point(x)),0,1).minimum)
    }

    get refPoint () { return this.point(0) }
}

////////////////////////////////////////////////////////////
// Line

/** Representing a line
 * @extends Curve
 */
class Line extends Curve {
    constructor(label) {
	super(label)
	const defaults = {
	    'points': false,
	    'arrow' : false, 
	    'arrowPosition' : 1, 
	    'point-style': style.point,
	    'line-style': style.line,
	    'labelPosition': 1/2,
	    'labelOffset' : 1.25
	}
	this.options = Object.assign(defaults, this.options)
	this.type = 'infinite'
	this.pivot = [0, 0]
	this.vector = [1, 0]
	this.length = Infinity
	this.resetEquations()
    }
    
    // ------------------------------------------------------------
    // Figure implementation
    copy () {
	// tested
	const res = new Line()
	Object.assign(res.options, this.options)
	res.pivot = this.pivot.copy()
	res.vector = this.vector.copy()
	res.type = this.type
	res.resetEquations()
	return res
    }
    
    transform (T) {
	// tested
	const p1 = this.point(0).transform(T),
	      p2 = this.point(1).transform(T)
	return this.joining(p1, p2)
    }

    isEqual (that) {
	// tested
	return (that instanceof Line) &amp;&amp;
	    equal(this.pivot, that.pivot) &amp;&amp;
	    equal(this.vector, that.vector)
    }

    isSimilar (obj) {
	// tested
	return (obj instanceof Line) &amp;&amp;
	    this.isContaining(obj.point(0)) &amp;&amp;
	    this.isContaining(obj.point(1))
    }

    // ------------------------------------------------------------
    // Curve implementation
    resetEquations () {
	let x0,y0,vx,vy;
	[x0,y0] = this.pivot;
	[vx,vy] = this.vector;
	this.point = s => point([x0 + s * vx, y0 + s * vy])
	this.equation = ([x,y]) => equal(vy*(x - x0), vx*(y - y0))
	return this
    }

    tangentV (t) {
	//tested 
	return this.vector.normalize()
    }

    location (point) {
	//tested
	var v = point.xy.vsub(this.pivot)
	return v.dot(this.vector)/this.vector.norm()**2
    }

    isContaining (point) {
	return equal(cross(this.vector, point.xy.vsub(this.pivot)), 0)
    }
    
    intersectionL (line) {
	if (equal(this.pivot, line.pivot))
	    return [point(this.pivot)]
	if (this.isParallelTo(line))
	    return []
	return [point(intersectionV(this.pivot, this.vector,
				    line.pivot, line.vector))]
    }

    intersections (obj) {
	console.assert(obj instanceof Curve,
		       "Intersections could be found only for curves.")
	let res = [];
	if (obj instanceof Line)
	    res = this.intersectionL(obj)
	if (obj instanceof Circle)
	    res = obj.intersectionL(this)
	if (obj instanceof Polygon)
	    res = obj.intersections(this)
	return res.filter(p => obj.isContaining(p) &amp;&amp; this.isContaining(p))
	    .sorted((p1,p2) => this.location(p1) - this.location(p2))
    }
    
    flip (s = 0) { return this.reflectAt(this.point(s)) }
    
    // ------------------------------------------------------------
    // Line methods

    // main constructor
    joining(point1, point2) {
	const res = this.copy(),
	      v = vector(point1, point2)
	res.pivot = point1.xy
	res.vector = v
	res.resetEquations()
	return res
    }

    through (point, v = this.vector) {
	const res = this.copy()
	res.pivot = point.xy
	res.vector = v
	res.resetEquations()
	return res
    }
    
    atAngle(angle_degrees) {
	// tested
	const res = this.copy()
	const r = deg2rad(angle_degrees)
	res.vector = [cos(r), sin(r)]
	res.resetEquations()
	return res
    }
        
    parallelTo (line) {
	// tested
	return this.atAngle(line.angle(0))
    }
    
    along (line) {
	// tested
	return this.through(line.point(0)).parallelTo(line)
    }

    get extension () {	return new Line().along(this) }
    
    perpendicularTo (line) {
	// tested
	return this.atAngle(line.angle(0)+90)
    }
    
    bisectrisse (angle) {
	// tested
	return this.atAngle((angle.start + angle.end)/2)
    }
    
    midPerpendicular (segment) {
	// tested
	return this.through(segment.point(1/2)).perpendicularTo(segment)
    }

    tangentTo(circle, direction = 1) {
	console.assert(this.point(0).distance(circle.center) >= circle.R,
		       "The pivot point of the tangent line is inside the circle!")
	
	const d = segment(this.point(0), circle.center)
	const a = direction * rad2deg(Math.asin(circle.R/d.length))
	return this.atAngle(d.angle(0)+a)
    }

    isParallelTo (line) {
	// tested
	return equalMod(180, line.angle(0),  this.angle(0))
    }

    isPerpendicularTo (line) {
	// tested
	return equalMod(180, line.angle(0) - this.angle(0), 90)
    }

    isTangentTo (circle) {
	return equal(circle.center.distance(this), circle.R)
    }

    isCCW (line) {
	console.assert(line instanceof Line,
		       "isCCW could be computed only for lines")
	return cross(this.vector, line.vector) >= 0
    }        

    
    distance (obj) {
	// tested
	console.assert(obj instanceof Point || obj instanceof Circle,
		      'object must be a point or a circle!')
	
	if (obj instanceof Point)
	    return obj.distance(this)

	return abs(this.distance(obj.center) - obj.R)
    }

    get box () {
	const ts = plane.intersections(this).map(p => this.location(p)).sorted()
	if (ts.length &lt; 2) return Box.mempty
	return Box.mappend(this.point(ts[0]).box, this.point(ts[1]).box)
    }
    
    show (paper) {
	const ts = plane.intersections(this).map(p => this.location(p)).sorted()
	if (ts.length &lt; 2) return
	paper.line([this.point(ts[0]).xy, this.point(ts[1]).xy], this.options)
	
	if (this.isLabeled)
	{
	    const lp = this.point(ts[1]).xy.vsub(this.tangentV(0).scale(2))
	    const lpos = lp.vadd([-0.5, -0.5])
	    const loff = this.normalV(0).scale(this.option('labelOffset'))
	    mkLabel(paper, this.option('label'), lpos.vadd(loff))
	}
	if (this.option('arrow'))
	{
	    const x = this.option('arrowPosition')
	    paper.arrow([this.point(x - 0.1).xy, this.point(x).xy], this.options)
	}
    }

    labelPosition (x) {
	return this.option('labelPosition', x)
    }
    
}

/** Representing a line
 * @extends Line
 */
class Ray extends Line {

    constructor(label) {
	super(label)
	const defaults = {
	    'labelOffset' : 1.25
	}
	this.options = Object.assign(defaults, this.options)
    } 

    // ------------------------------------------------------------
    // Figure implementation
    copy () {
	// tested
	const res = new Ray()
	Object.assign(res.options, this.options)
	res.pivot = this.pivot.copy()
	res.vector = this.vector.copy()
	res.resetEquations()
	return res
    }
    
    isEqual (obj) {
	// tested
	return (obj instanceof Ray)
	    &amp;&amp; super.isEqual(obj)
    }

    isSimilar (obj) {
	// tested
	return (obj instanceof Ray)
	    &amp;&amp; this.start.isEqual(obj.start)
	    &amp;&amp; equal(this.tangentV(0), obj.tangentV(0))
    }

    // ------------------------------------------------------------
    // Curve implementation

    isContaining (point) {
	return super.isContaining(point)
	    &amp;&amp; this.location(point) >= 0
    }
    
    // ------------------------------------------------------------
    // Ray methods

    get start () { return this.point(0) }

    // ------------------------------------------------------------
    // BoxedFigure implementation 

    get box () {
	const t = this.location(this.intersections(plane)[0])
	return Box.mappend(this.point(0).box, this.point(t).box)
    }
    
    show (paper) {
	const t = this.location(this.intersections(plane)[0])
	paper.line([this.point(0).xy, this.point(t).xy], this.options)
	
	if (this.isLabeled)
	{
	    const lp = this.point(t).xy.vsub(this.tangentV(0).scale(2))
	    const lpos = lp.vadd([-0.5, -0.5])
	    const loff = this.normalV(0).scale(this.option('labelOffset'))
	    mkLabel(paper, this.option('label'), lpos.vadd(loff))
	}
	if (this.option('arrow'))
	{
	    const x = this.option('arrowPosition')
	    paper.arrow([this.point(x - 0.1).xy, this.point(x).xy], this.options)
	}
    }
}

/** Representing a segment
 * @extends Line
 */
class Segment extends Line {
    constructor(label) {
	super(label)
	const defaults = {
	    'mark' : 0, 
	    'labelPosition' : 1/2, 
	    'labelOffset' : 1.25
	}
	this.type = 'finite'
	this.length = 1
	this.options = Object.assign(defaults, this.options)
    }

    // ------------------------------------------------------------
    // Figure implementation
    copy () {
	// tested
	const res = new Segment()
	Object.assign(res.options, this.options)
	res.pivot = this.pivot.copy()
	res.vector = this.vector.copy()
	res.length = this.length
	res.resetEquations()
	return res
    }

    isEqual (obj) {
	return (obj instanceof Segment) &amp;&amp;
	    super.isEqual(obj)
    }

    isSimilar (segment) {
	//tested
	return (segment instanceof Segment)
	    &amp;&amp; equal(this.length, segment.length)
    }

    // ------------------------------------------------------------
    // Curve implementation
    resetEquations () {
	super.resetEquations()
	this.length = this.vector.norm()
	return this
    }
    
    isContaining (point) {
	return super.isContaining(point)
	    &amp;&amp; this.location(point) >= 0
	    &amp;&amp; this.location(point) &lt;= 1
    }

    // ------------------------------------------------------------
    // Segment methods
   
    get start () { return this.point(0) }
    get end () { return this.point(1) } 
    get middle () { return this.point(1/2) }
    
    extend (t1, t2 = null) {
	//tested
	if (!t2)
	    return this.joining(this.point(0), this.point(t1))
	else
	    return this.joining(this.point(t1), this.point(t2))
    }

    extendToLength (number) {
	// tested
	const p = this.pivot.vadd(this.tangentV(0).scale(number))
	return this.joining(this.start, point(p))
    }

    extendToLine (line) {
	// tested
	var e = line.extension
	if (e.isContaining(this.start))
	    return this.extend(0)
	if (this.isParallelTo(line))
	    return new Ray().through(this.start).parallelTo(this)
	else
	    return this.joining(this.start, e.intersections(this.extension)[0])
    }

    extendTo (obj) {
	console.assert(obj instanceof Curve,
		       "Segment could extended only to a curve!")
	if (obj instanceof Line)
	    return this.extendToLine(obj)
	if (obj instanceof Curve) {
	    let r = new Ray().through(this.start).parallelTo(this),
		int = r.intersections(obj)
	    if (int.length == 0)
		return r
	    else
		return this.joining(this.start, int[0])
	}
	return this
    }
    
    heightTo (line) {
	// tested
	return this.perpendicularTo(line).extendToLine(line)
    }

    tangentTo(circle, direction = 1) {
	// tested
	const d = this.start.distance(circle.center)
	const t = new Ray().through(this.start).tangentTo(circle, direction)
	if (equal(d, circle.R)) {
	    return this.parallelTo(t)
	} else if (d &lt; circle.R) {
	    console.log()
	    return this
	} else {
	    const p = this.parallelTo(t).extendToLength(sqrt(d**2-circle.R**2)).end
	    const a = circle.location(p)
	    return this.joining(this.start, circle.point(a))
	}
    }

    shortestTo (obj) {
	let s = this.start
	if (obj instanceof Line) {
	    let e, h = new Segment().through(s).heightTo(obj)
	    if (obj.isContaining(h.end))
		e = h.end
	    else if (obj instanceof Ray)
		e = obj.start
	    else
		e = [obj.start, obj.end].minBy(p => this.distance(p))
	    return this.joining(s, e)
	}
	if (obj instanceof Polygon)
	    return obj.sides.map(s => this.shortestTo(s)).minBy(x => x.length)
	if (obj instanceof Circle)
	    return this.joining(s, obj.point(obj.location(s)))
	return this
    }
    
    internal (points) {
	return points.filter(p => this.isContaining(p))
    }

    flip (s = 1/2) { return super.flip(s) }

    get box () {
	const ts = plane.intersections(this).map(p => this.location(p)).sorted()
	if (ts.length &lt; 2) return Box.mempty
	return Box.mappend(this.point(max(0,ts[0])).box, this.point(min(1,ts[1])).box)
    }

    clipBy (curve) {
	let is = [this.start, this.intersections(curve), this.end]
	    .flat()
	var parts = is.zipWith(is.tail(), segment)
	return new Group(parts.filter(p => curve.isEnclosing(p.middle)))
    }
        
    show (paper)
    {
	this.clipBy(plane)
	    .contents
	    .forEach(p => paper.line([p.start.xy, p.end.xy], this.options))
	    
	if (this.isLabeled)
	{
	    const lp = this.point(this.option('labelPosition')).xy
	    const lpos = lp.vadd([-0.5, -0.5])
	    const loff = this.normalV(0).scale(this.option('labelOffset'))
	    mkLabel(paper, this.label(), lpos.vadd(loff))
	}
	if (this.option('arrow'))
	{
	    const x = this.option('arrowPosition')
	    paper.arrow([this.point(x - 0.1).xy, this.point(x).xy], this.options)
	}
	if (this.option('mark') > 0)
	{
	    for (let i = 0; i &lt; this.option('mark'); i++) {
		const m = this.point(1/2).xy.vadd(this.tangentV(0).scale(0.2*i))
		paper.line([m.vadd(this.normalV(0).scale(0.3)), 
			    m.vadd(this.normalV(0).scale(-0.3))], 
			   {'class':'thin'})
	    }
	}
    }

    mark (n) { return this.option('mark', n) }
    arrow () { return this.option('arrow', true) }
    points (t) { return this.option('points', t) }

}

var l


////////////////////////////////////////////////////////////
// Angle

/** Representing an angle
 * @extends BoxedFigure
 */
class Angle extends BoxedFigure {
    constructor (value = 'value') {
	super(value)
	const defaults = {
	    'strokes' : 1, 
	    'labelRadius' : 3, 
	    'line-style': style.angle,
	}
	this.options = Object.assign(defaults, this.options)
	this.start = 0
	this.end = Number.isFinite(value) ? value % 360 : 0
	this.vertex = origin
    }
    
    copy () {
	//tested
	const res = new Angle()
	Object.assign(res.options, this.options)
	res.start = this.start
	res.end = this.end
	res.vertex = this.vertex.copy()
	return res
    }

    isEqual (obj) {
	//tested
	return (obj instanceof Angle)
	    &amp;&amp; equalMod(360, this.start, obj.start)
	    &amp;&amp; equalMod(360, this.end, obj.end)
	    &amp;&amp; this.vertex.isEqual(obj.vertex)
    }

    isSimilar (obj) {
	//tested
	return (obj instanceof Angle)
	    &amp;&amp; equalMod(360, this.value, obj.value)
    }

    on (line) {
	//tested
	const res = this.copy()
	res.vertex = point(line.pivot)
	res.start = line.angle(0)
	res.end = res.start + this.value
	return res
    }

    get refPoint () { return this.vertex }
    
    at (pos) {
	//tested
	const res = this.copy()
	res.vertex = pointOrXY(pos).point
	return res
    }
    
    transform (T) {
	//tested
	const res = this.copy()
	res.vertex = this.vertex.transform(T)
	res.start = this.startRay.transform(T).angle(0)
	res.end = this.endRay.transform(T).angle(0)
	return res
    }
    
    get value () { return (2*360 + this.end - this.start) % 360 }
    get startRay () {
	return new Ray().through(this.vertex).atAngle(this.start)
    }
    get endRay () {
	return new Ray().through(this.vertex).atAngle(this.end)
    }
    get isRight () {
	return equalMod(360, this.value, 90) || cos(deg2rad(this.value)) &lt; 1e-14
    }

    setValue (angle) {
	//tested
	const res = this.copy()
	res.end = this.end + angle
	return res	
    }
    
    vertical () {
	// tested 
	return this.rotateAt(this.vertex, 180)
    }

    adjacent () {
	// tested 
	const res = this.copy()
	res.start = this.end
	res.end = (this.start + 180) % 360
	return res
    }

    complement () {
	// tested 
	const res = this.copy()
	res.start = this.end
	res.end = this.start
	return res
    }
    
    within (point1, point2, point3) {
	// tested
	const res = this.copy()
	res.start = ray(point2, point1).angle(0)
	res.end = ray(point2, point3).angle(0)
	res.vertex = point2
	return res
    }
    
    between (line1, line2) {
	// tested
	const res = this.copy()
	res.start = line1.angle(0)
	res.end = line2.angle(0)
	res.vertex = line1.point(0)
	return res
    }
   
    show (p) {
	if (this.isRight)
	{
	    const p0 = this.vertex.xy
	    const p1 = this.startRay.tangentV(0)
	    const p2 = this.endRay.tangentV(0)
	    p.line([p1, p1.vadd(p2), p2].map(p => p0.vadd(p)), this.options)
	    return
	}

	for(let i = 0; i &lt; this.options['strokes']; i++)
	    p.arc(this.vertex.xy, 2-i*0.3, this.start, this.end, this.options)

	if (this.isLabeled)
	{
	    let l = this.option('label')
	    if (l == 'value')
		l = abs(round(this.value))+'°'
	    const r = this.option('labelRadius')
	    const lpos = new Ray().bisectrisse(this).tangentV(0).scale(r)
		  .vadd(this.vertex.xy).vadd([-0.5,-0.7])
	    mkLabel(p,l,lpos)
	    
	}
    }

    strokes (n) { return this.option('strokes', n) }
}

////////////////////////////////////////////////////////////
// Polygon

/** Representing a polygon or a polyline
 * @extends Curve
 */
class Polygon extends Curve {
    constructor(label) {
	super(label)
	const defaults = {
	    'labelPosition' : 'automatic',
	    'points' : false,
	    'segmentLabels':[],
	    'point-style': style.point,
	    'line-style': style.polygon
	}
	this.options = Object.assign(defaults, this.options)
	this.type = 'finite'
	this.vertices = []
	this.verticesLocations = []
    }

    //------------------------------------------------------------
    // Figure implementation
    
    copy () {
	const res = new Polygon()
	Object.assign(res.options, this.options)
	res.type = this.type
	res.vertices = this.vertices.map(v => v.copy())
	res.resetEquations()
	return res
    }

    transform (T) {
	const res = this.copy()
	res.vertices = this.vertices.map(v => v.transform(T))
	res.resetEquations()
	return res
    }

    isEqual (obj) {
	return (obj instanceof Polygon)
	    &amp;&amp; equal(this.vertices, obj.vertices)
    }

    //------------------------------------------------------------
    // Curve implementation

    resetEquations () {
	if(this.vertices.length &lt; 2) return this
	let pts = this.vertices.map(p => p.xy)
	const par = naturalParametrization(pts, this.type)
	this.point = s => point(par.eqn(s))
	this.length = par.length
	this.verticesLocations = par.pointLocations
	this.equation = undefined
	return this
    }

    isContaining (point) {
	return this.sides.some(s => s.isContaining(point)) 
    }

    location (point) {
	let i = this.sides.map(s => s.location(point)).findIndex(l => 0 &lt;= l &amp;&amp; l &lt;= 1)
	console.assert(i != -1,
		       `Point [${point.xy}] can't be located on a curve ${this.label()}.`)
	let s = this.sides[i],
	    l0 = this.verticesLocations[i],
	    l1 = s.location(point)*s.length/this.length
	return l0 + l1
    }
    
    flip () {
	let res = this.copy()
	res.vertices = this.vertices.reversed()
	this.resetEquations()
	return this
    }

    intersections (obj) {
	return this.sides.mapappend(s => s.intersections(obj)
				    .filter(p => s.isContaining(p) &amp;&amp; obj.isContaining(p)))
    }
    
    //------------------------------------------------------------
    // Polygon methods

    addVertex (pos, n = this.number) {
	var res = this.copy()
	res.vertices.insert(n, pointOrXY(pos).point)
	res.resetEquations()
	return res
    }
    
    setType (t) {
	this.type = t
	return this
    }

    get number () { return this.vertices.length }
    
    get sides () {
	let res = [], vs
	if (this.isClosed)
	    vs = this.vertices.concat([this.vertices[0]])
	else
	    vs = this.vertices
	for(let i = 0; i &lt; vs.length-1; i++) {
	    const s = this.options.segmentLabels[i]
	    res.push(new Segment(s).joining(vs[i], vs[i+1]))
	}
	return res
    }
    
    vertex (i) {
	if (this.isClosed)
	    return this.vertices[(this.number + i - 1) % this.number]
	else {
	    console.assert(i > 0 &amp;&amp; i &lt;= this.number,
			   `The polygon has ${this.number} vertices, requested ${i}.`)
	    return this.vertices[i - 1]
	}
    }

    vertexLocation (i) {
	if (this.isClosed)
	    return this.verticesLocations[(this.number + i - 1) % this.number]
	else {
	    console.assert(i > 0 &amp;&amp; i &lt;= this.number,
			   `The polygon has ${this.number} vertices, requested ${i}.`)
	    return this.verticesLocations[i - 1]
	}
    }
    
    side (i) {
	if (this.isClosed)
	    return this.sides[(this.number + i - 1) % this.number]
    	else {
	    console.assert(i > 0 &amp;&amp; i &lt;= this.number-1,
			   `The polygon has ${this.number-1} sides, requested ${i}.`)
	    return this.sides[i - 1]
	}
    }
    
    vertexAngle (i) {
	if (this.isClosed) 
	    console.assert(i > 0 &amp;&amp; i &lt;= this.number-2,
			   `The polygon has ${this.number-2} angles, requested ${i}.`)
	let v1 = this.vertex(i-1),
	    v2 = this.vertex(i),
	    v3 = this.vertex(i+1)
	return new Angle().within(v1,v2,v3)
    }

    labelVertices (labels) {
	this.vertices.map((v,i) => v.label(labels[i]))
	return this
    }
    
    labelSegments (labels) { return this.option('segmentLabels',labels) }
   
    at (pos, vertex_n = 1) {
	return this.superpose(this.vertex(vertex_n), pointOrXY(pos).point)
    }
    
    through (points) {
	const res = this.copy()
	res.vertices = points.copy()
	res.resetEquations()
	return res
    }

    on (segment, side_n = 1) {
	return this.scaleAt(this.vertex(side_n), segment.length/this.side(side_n).length)
	    .align(this.side(side_n), segment)
	    .at(segment.start, side_n)
    }

    parametric (fn, domain) {
	return this.through(domain.map(s => point(fn(s))))
    }

    polar (fn, n = 50, start = 0, end = 2*pi) {
	let step = (end - start)/n
	return this.parametric(t => [cos(t), sin(t)].scale(fn(t)),
			       range(start, end+step, step))
    }

    circleSegment (r = 1, start = 0, end = 2*pi) {
	return this.polar(t => r, (end - start)/(2*pi/100), start, end)
    }

    sector (r = 1, start = 0, end = 2*pi) {
	return this.circleSegment(r, start, end)
    }

    regular (n, r = 1) {
	return this.polar(t => r, n).rotate(90).closed()
    }
   
    get box () {
	return this.vertices.foldMap(v => v.box, Box)
    }
    
    show (paper)
    {
	this.sides.forEach(s => s.show(paper))

	return 
	let pts = this.vertices.map(v => v.xy)
	if (this.isClosed)
	    pts = pts.concat([pts[0]])
	
	paper.listLinePlot(pts, this.options)

	if (this.option('points'))
	    this.vertices.forEach(s => s.show(paper))

    }

    fill (c) {
	return this.lineStyle({'fill': c})
    }

    opacity (n) {
	return this.lineStyle({'fill-opacity': n})
    }
    
    points (bool) {
	this.options['points'] = bool
	return this
    }

    noline () {
	return this.lineStyle({'stroke': 'none'})
    }
    
    joined (bool) {
	this.options['joined'] = bool
	return this
    }  
}

/** Representing a triangle
 * @extends Polygon
 */
class Triangle extends Polygon {
    constructor (point1 = null, point2 = null, point3 = null) {
	super()
	const defaults = { }
	this.options = Object.assign(defaults, this.options)
	let s
	if (!point1) {
	    s =  new Polygon().regular(3)
	} else if (!point2) {
	    s =  new Polygon().regular(3).at(point1)
	} else if (!point3) {
	    s = new Polygon().regular(3).on(segment(point1,point2))
	} else {
	    s = new Polygon().through([point1, point2, point3])
	}
	this.vertices = s.vertices
	this.type = 'closed'
	return this.resetEquations()
    }

    copy () { return super.copy(new Triangle()) }

    withAngles (angle1, angle2 = angle1) {
	console.assert(!equalMod(180, angle1 + angle2, 0), 
		       `Angles ${angle1} and ${angle2} do not form a triangle`)
	const a = this.vertex(1),
	      b = this.vertex(2)
	return new Triangle(a, b, new Point().azimuth(a, angle1, b, angle2))
    }

    withHeight (height, vertex_n = 2) {
	const h = this.height(vertex_n)
	return this.stretchAt(this.vertex(vertex_n - 1), h, height/h.length)
    }
    
    median (i) {
	const v = this.vertex(i),
	      s = this.side(i+1)
	return new Segment().joining(v, s.point(1/2))
    }
    
    height (i) {
	const v = this.vertex(i),
	      s = this.side(i+1)
	return new Segment().through(v).heightTo(s)
    }

    bisectrisse (i) {
	const v = this.vertex(i),
	      a = this.vertexAngle(i),
	      s = this.side(i+1)
	return new Segment().through(v).bisectrisse(a).extendToLine(s)
    }

}

/** Representing a quadrilateral polygon
 * @extends Polygon
 */
class Quadrilateral extends Polygon {
    constructor () {
	super()
	const defaults = {
	    'closed' : true
	}
	this.options = Object.assign(defaults, this.options)
	this.type = 'closed'
    }

    copy () { return super.copy(new Quadrilateral()) }

    through (points) {
	let res = this.copy()
	res.vertices = points.take(4)
	res.resetEquations()
	return res
    }
    
    transform (T) {
	const res = this.copy(),
	      s = super.transform(T)
	res.vertices = s.vertices
	return res
    }

    diagonal (i) { return segment(this.vertex(i),this.vertex(i+2)) }
}

/** Representing a square
 * @extends Quadrilateral
 */
class Square extends Quadrilateral {

    constructor (side = 1) {
	super()
	const defaults = { }
	this.options = Object.assign(defaults, this.options)
	const a = side/2
	this.vertices = [point([-a,-a]), point([a,-a]),
			 point([a,a]), point([-a,a])]
	this.resetEquations()
    }

    copy () { return super.copy(new Square()) }

    through (p1,p2) {
	return new Square(segment(p1,p2).length)
    }
    
    sideLength (number) {
	const res = this.copy(),
	      a = this.side(1).length
	return res.scaleAt(this.vertex(1), number/a)
    }    
}

/** Representing a rectangle
 * @extends Quadrilateral
 */
class Rectangle extends Quadrilateral {

    constructor (side1 = 1, side2 = side1) {
	super()
	const defaults = { }
	this.options = Object.assign(defaults, this.options)
	const a = side1/2, b = side2/2
	this.vertices = [point([-a, -b]), point([a, -b]),
			 point([a, b]), point([-a, b])]
	this.resetEquations()
    }

    copy () { return super.copy(new Rectangle()) }

    through (p1, p2, p3) {
	return new Rectangle(segment(p1, p2).length, segment(p2, p3).length)
    }

    get width () { return this.side(1).length }
    get height () { return this.side(2).length }
    
    sideLength (width, height) {
	const res = this.copy()
	return res.scaleAt(this.vertex(1), width/this.width, height/this.height)
    }
}

////////////////////////////////////////////////////////////
// Circle
/** Representing a circle
 * @extends Curve
 */
class Circle extends Curve {
    constructor(r = 1) {
	super()
	const defaults = {
	    'style': style.circle
	}
	this.options = Object.assign(defaults,this.options)
	this.type = 'closed'
	this.center = origin.copy()
	this.R = r
	this.phase = 0
	this.orientation = Math.sign(cross([1, 0], [0,1]))
	this.resetEquations()
    }

    //------------------------------------------------------------
    // Figure implementation
    copy () {
	const res = new Circle(this.R)
	Object.assign(res.options, this.options)
	res.R = this.R
	res.center = this.center.copy()
	res.phase = this.phase
	res.orientation = this.orientation
	res.resetEquations()
	return res
    }
    
    transform (T) {
	const r = this.radius(0).transform(T)
	const t = this.tangentV(0)
	const res = new Circle()
	res.R = r.length
	res.center = r.start
	res.phase = res.location(r.end)
	res.orientation = Math.sign(cross(r.vector, trans(T,t)))
	res.resetEquations()
	return res
    }

    isEqual (obj) {
	return (obj instanceof Circle) &amp;&amp;
	    equal(this.center, obj.center) &amp;&amp;
	    equal(this.R, obj.R)
    }

    isSimilar (obj) {
	return this.isEqual(obj)
    }

    get refPoint () { return this.center }
    
    //------------------------------------------------------------
    // Curve implementation
    resetEquations () {
	const c = this.center,
	      r = this.R,
	      ph = this.phase,
	      w = this.orientation
	this.point = t => point([c.x+this.R*cos(2*pi*(w*t + ph)),
				 c.y+this.R*sin(2*pi*(w*t + ph))])
	this.length = 2*this.R*pi
	this.equation = xy => equal(point(xy).distance(this.center), this.R)
    }

    tangentV (t) {
	const ph = this.phase,
	      w = this.orientation
	return [-w*sin(2*pi*(w*t + ph)), w*cos(2*pi*(w*t + ph))]
    }

    location (point) {
	return deg2rad(line(this.center, point).angle(0))/(2*pi)
    }
    
    isEnclosing (point) {
	return point.distance(this.center) &lt;= this.R
    }

    flip () {
	let res = this.copy()
	Object.assign(res.options, this.options)
	res.orientation = -this.orientation
	return res
    }
    
    //------------------------------------------------------------
    // Circle methods

    radius (s = 0) { return segment(this.center, this.point(s)) }
  
    intersectionC (that) {
	const r0 = this.R,
	      r1 = that.R,
	      r = segment(this.center, that.center),
	      R = r.length
	if (R == 0)
	    return []
	if (R > r0 + r1 || R &lt; abs(r0-r1))
	    return []
	const a = (r0**2 - r1**2)/(2*R),
	      b = 1/2*sqrt(2*(r0**2 + r1**2) - 4*a**2 - R**2),
	      m = r.middle.xy.vadd(r.tangentV(0).scale(a))
	if (b == 0)
	    return [point(m.vadd(r.normalV(0).scale(b)))]
	else 
	    return [point(m.vadd(r.normalV(0).scale(b))), point(m.vadd(r.normalV(0).scale(-b)))]
    }

    intersectionL (line) {
	const h = new Segment().through(this.center).heightTo(line)
	if (equal(h.length, this.R))
	    return [h.end]
	if (h.length > this.R)
	    return []
	const x = sqrt(this.R**2 - h.length**2),
	      s = new Segment().through(h.end).parallelTo(line).extend(-x,x)
	return [s.end,s.start]
    }

    intersections (obj) {
	var res = []
	if (obj instanceof Line)
	    res = this.intersectionL(obj)
	if (obj instanceof Circle)
	    res = this.intersectionC(obj)
	if (obj instanceof Polygon)
	    res = obj.intersections(this)
	return res.filter(p => obj.isContaining(p) &amp;&amp; this.isContaining(p))
	    .sorted((p1,p2) => this.location(p1) - this.location(p2))
    }
    
    through1 (point) {
	this.R = segment(this.center, point).length
	this.resetEquations()
	return this.copy()
    }

    through2 (p1, p2) {
	const d = p1.distance(p2)
	if (d > this.R*2) {
	    this.R = d/2
	    this.center = segment(p1,p2).middle
	} else {
	    const c1 = new Circle(this.R).at(p1),
		  c2 = new Circle(this.R).at(p2)
	    this.center = c1.intersectionC(c2)[0]
	}
	this.resetEquations()
	return this.copy()
    }

    through3 (p1,p2,p3) {
	const l1 = new Line().midPerpendicular(segment(p1,p2)),
	      l2 = new Line().midPerpendicular(segment(p2,p3))

	console.assert(!l1.isParallelTo(l2),
		       "Can't build a circle, three points are aligned.")
	
	this.center = new Point().intersections(l1,l2)[0]
	this.R = this.center.distance(p1)
	this.resetEquations()
	return this.copy()
    }

    through (point1, point2, point3) {
	if (!point2  &amp;&amp; !point3)
	    return this.through1(point1)
	else if (!point3)
	    return this.through2(point1, point2) 
	else
	    return this.through3(point1, point2, point3)
    }

    distance (obj) {
	console.assert( obj instanceof Point ||
			obj instanceof Line ||
			obj instanceof Circle,
			'object must be a line, point or a circle!')
	
	if (obj instanceof Point || obj instanceof Line)
	    return obj.distance(this)

	return abs(this.distance(obj.center) - obj.R - this.R)
    }


    get box () {
	return range(0,1,1/4).foldMap(t => this.point(t).box, Box)
    }
    
    show (paper) {
	paper.disk(this.center.xy, this.R, this.options)
    }
}

////////////////////////////////////////////////////////////
// Text
/** Representing a text ona chart
 * @extends BoxedFigure
 */
class Text extends BoxedFigure {
    constructor (text)
    {
	super(text)
	const defaults = {
	    'labelOffset': [0, 0],
	    'label-style': style.text
	}
	this.options = Object.assign(defaults, this.options)
	this.pivot = origin
	this.angle = 0
    }

    copy () {
	const res = new Text()
	Object.assign(res.options, this.options)
	res.pivot = this.pivot.copy()
	res.angle = this.angle
	return res
    }

    get refPoint () { return this.pivot }
    
    at (pos) {
	const res = this.copy()
	res.pivot = pointOrXY(pos).point
	return res
    }

    on (line, t = 0) {
	let res = this.copy()
	res.pivot = line.point(t)
	return res.atAngle(line.angle(0)).option('labelOffset',line.normalV(0).scale(2/3))
    }

    transform (T) {
	const res = this.copy()
	res.pivot = this.pivot.transform(T)
	return res
    }

    atAngle (a) {
	const res = this.copy()
	res.angle = a
	return res
    }

    get length () {
	return this.label().length
    }
    
    get box () {
	return new Rectangle(this.length*0.75, 1)
	    .at(this.pivot)
	    .rotateAt(this.pivot, this.angle)
	    .box
    }

    show (paper) {
	if (this.isLabeled) {
	    const l = this.options.label,
		  lp = this.pivot.xy.vadd(this.option('labelOffset'))
	    mkLabel(paper, l, lp
		    , Object.assign(this.options, {'style' : style.text
						   ,'angle' : this.angle + 1e-10}))
	}
    }
    
}

////////////////////////////////////////////////////////////
// Scale
/** Representing a group scale on a curve
 * @extends BoxedFigure
 */
class Scale extends BoxedFigure {
    constructor(steps = 2, labelF = x => x, format = fmt.fixed2) {
	super()
	const defaults = {
	    'tickLength' : 0.5,
	    'labelF' : labelF,
	    'format' : format,
	    'labels' : true,
	    'range' : range(0, 1+1/steps, 1/steps),
	    'unit' : 1,
	    'closed' : false
	}
	this.options = Object.assign(defaults, this.options)
	this.steps = steps
	this.curve = new Segment()
    }

    copy () {
	const res = new Scale()
	Object.assign(res.options, this.options)
	res.steps = this.steps
	res.curve = this.curve.copy()
	return res	
    }

    transform (T) {
	const res = this.copy()
	res.curve = this.curve.transform(T)
	return res	
    }

    get refPoint () { return this.curve.point(0) }
    
    on (curve) {
	console.assert(curve instanceof Curve,
		       "Scale must lay on a curve.")
	var res = this.copy()
	Object.assign(res.options, this.options)
	res.curve = curve.copy()
	return res
    }

    lableFunction (func) { return this.option('labelF', func) }
    unit (u) { return this.option('unit', u || 1) }
    closed (bool = true) { return this.option('closed', bool) }
    format (func) { return this.option('format', func) }
    tickLength (v) { return this.option('tickLength', v) }
    noLabels () { return this.option('labels', false) }

    circular() { return this.unit(this.steps).closed() }
    
    range ([a, b]) {
	let s = (b-a)/this.steps
	return this.option('range', range(a, b + s, s))
    }

    flip () {
	let res = this.copy()
	Object.assign(res.options, this.options)
	res.curve = this.curve.flip()
	return res
    }
    
    get group () {
	const tick = x => {
	    let p = this.curve.point(x)
	    let s = new Segment().through(p)
		.atAngle(this.curve.angle(x) + 90)
		.extendToLength(this.tickLength())
	    let l = false, u = this.options.unit
	    if (this.options.labels)
		l = s.end.invisible().label(this.format()(this.lableFunction()(u*x)))
		.labelOffset(s.tangentV(0).scale(abs(this.tickLength())))
	    return l ? new Group([s,l]) : s
	}
	if (this.options.closed)
	    return new Group(this.options.range.most().map(tick))
	else
	    return new Group(this.options.range.map(tick))
    }

    show (paper) { this.group.show(paper) }
}

////////////////////////////////////////////////////////////
// predefined objects

/** Representing a chart */
class Chart {
    constructor (fig)
    {
	this.svg = new SVG(fig, Object.assign({'size':600},style.svg))
	this.paper = new Graphics(this.svg,
				  {'size':600,'aspectRatio':1,
				   'left-margin':10,'right-margin':10,
				   'top-margin':10,'botom-margin':10,
				   'class':'chart'})
	    .xRange(xRange)
  	    .yRange(yRange)
    }

    save (name) { this.svg.save(name) }
    
    clear() { return this.paper.cleanPaper() }

    adjustSize () {
	this.paper.adjustSize()
	return this
    }
    
    put ()
    {
	[...arguments].flat().forEach(o => o.show(this.paper))
	return this
    }
}

////////////////////////////////////////////////////////////
// smart constructors

const point = ([x, y]) => new Point().at([x, y])

function line (point, point_or_angle = 0) {
    if (point_or_angle instanceof Point)
	return new Line().joining(point, point_or_angle)
    else
	return new Line().through(point).atAngle(point_or_angle)
}

function ray (point, point_or_angle = 0) {
    if (point_or_angle instanceof Point)
	return new Ray().joining(point, point_or_angle)
    else
	return new Ray().through(point).atAngle(point_or_angle)
}

const segment = (a, b) => new Segment().joining(a, b)

const angle = (a,b,c) => new Angle().within(a,b,c)

function mkLabel(p, l, pnt, opts)
{
    let options = Object.assign({'at':pnt,'style':style.label}, opts)
    return p.label(l, options)
}

////////////////////////////////////////////////////////////
// predefined objects

const origin = new Point('O').at([0,0]).option('labelOffset',[-1,-1])
const Ox = new Line().through(origin).atAngle(0)
const Oy = new Line().through(origin).atAngle(90)
//gconst plane = new Square(paperSize)
const plane = new Circle(paperSize/2)
</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Sat Apr 25 2020 00:03:24 GMT+1200 (Petropavlovsk-Kamchatski Standard Time)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/jaguar.js"></script>
</body>
</html>
